{"version":3,"sources":["../../src/immer.ts","../../src/utils/env.ts","../../src/utils/errors.ts","../../src/utils/common.ts","../../src/utils/plugins.ts","../../src/core/scope.ts","../../src/core/finalize.ts","../../src/core/proxy.ts","../../src/core/immerClass.ts","../../src/core/current.ts","../../src/plugins/patches.ts","../../src/plugins/mapset.ts","../../src/plugins/arrayMethods.ts"],"sourcesContent":["import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tWritableDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\tProducer,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze,\n\tObjectish,\n\tStrictMode\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = /* @__PURE__ */ immer.produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to enable strict shallow copy.\n *\n * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n */\nexport const setUseStrictShallowCopy = /* @__PURE__ */ immer.setUseStrictShallowCopy.bind(\n\timmer\n)\n\n/**\n * Pass false to use loose iteration that only processes enumerable string properties.\n * This skips symbols and non-enumerable properties for maximum performance.\n *\n * By default, strict iteration is enabled (includes all own properties).\n */\nexport const setUseStrictIteration = /* @__PURE__ */ immer.setUseStrictIteration.bind(\n\timmer\n)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = /* @__PURE__ */ immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = /* @__PURE__ */ immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport let castDraft = <T>(value: T): Draft<T> => value as any\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport let castImmutable = <T>(value: T): Immutable<T> => value as any\n\nexport {Immer}\n\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableArrayMethods} from \"./plugins/arrayMethods\"\n","// Should be no imports here!\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n","import {isFunction} from \"../internal\"\n\nexport const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// All error codes, starting by 0:\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t\t\t\t\"Immer forbids circular references\",\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t\t\t\t\"Immer only supports deleting array indices\",\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\t\t\t\t// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n\t\t\t\t// See Patches.ts for additional errors\n\t\t  ]\n\t\t: []\n\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst e = errors[error]\n\t\tconst msg = isFunction(e) ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tArchType,\n\tdie,\n\tStrictMode\n} from \"../internal\"\n\nconst O = Object\n\nexport const getPrototypeOf = O.getPrototypeOf\n\nexport const CONSTRUCTOR = \"constructor\"\nexport const PROTOTYPE = \"prototype\"\n\nexport const CONFIGURABLE = \"configurable\"\nexport const ENUMERABLE = \"enumerable\"\nexport const WRITABLE = \"writable\"\nexport const VALUE = \"value\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport let isDraft = (value: any): boolean => !!value && !!value[DRAFT_STATE]\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tisArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value[CONSTRUCTOR]?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = O[PROTOTYPE][CONSTRUCTOR].toString()\nconst cachedCtorStrings = new WeakMap()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || !isObjectish(value)) return false\n\tconst proto = getPrototypeOf(value)\n\tif (proto === null || proto === O[PROTOTYPE]) return true\n\n\tconst Ctor = O.hasOwnProperty.call(proto, CONSTRUCTOR) && proto[CONSTRUCTOR]\n\tif (Ctor === Object) return true\n\n\tif (!isFunction(Ctor)) return false\n\n\tlet ctorString = cachedCtorStrings.get(Ctor)\n\tif (ctorString === undefined) {\n\t\tctorString = Function.toString.call(Ctor)\n\t\tcachedCtorStrings.set(Ctor, ctorString)\n\t}\n\n\treturn ctorString === objectCtorString\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/**\n * Each iterates a map, set or array.\n * Or, if any other kind of object, all of its own properties.\n *\n * @param obj The object to iterate over\n * @param iter The iterator function\n * @param strict When true (default), includes symbols and non-enumerable properties.\n *               When false, uses looseiteration over only enumerable string properties.\n */\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tstrict?: boolean\n): void\nexport function each(obj: any, iter: any, strict: boolean = true) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\t// If strict, we do a full iteration including symbols and non-enumerable properties\n\t\t// Otherwise, we only iterate enumerable string properties for performance\n\t\tconst keys = strict ? Reflect.ownKeys(obj) : O.keys(obj)\n\t\tkeys.forEach(key => {\n\t\t\titer(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_\n\t\t: isArray(thing)\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/*#__PURE__*/\nexport let has = (\n\tthing: any,\n\tprop: PropertyKey,\n\ttype = getArchtype(thing)\n): boolean =>\n\ttype === ArchType.Map\n\t\t? thing.has(prop)\n\t\t: O[PROTOTYPE].hasOwnProperty.call(thing, prop)\n\n/*#__PURE__*/\nexport let get = (\n\tthing: AnyMap | AnyObject,\n\tprop: PropertyKey,\n\ttype = getArchtype(thing)\n): any =>\n\t// @ts-ignore\n\ttype === ArchType.Map ? thing.get(prop) : thing[prop]\n\n/*#__PURE__*/\nexport let set = (\n\tthing: any,\n\tpropOrOldValue: PropertyKey,\n\tvalue: any,\n\ttype = getArchtype(thing)\n) => {\n\tif (type === ArchType.Map) thing.set(propOrOldValue, value)\n\telse if (type === ArchType.Set) {\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\nexport let isArray = Array.isArray\n\n/*#__PURE__*/\nexport let isMap = (target: any): target is AnyMap => target instanceof Map\n\n/*#__PURE__*/\nexport let isSet = (target: any): target is AnySet => target instanceof Set\n\nexport let isObjectish = (target: any) => typeof target === \"object\"\n\nexport let isFunction = (target: any): target is Function =>\n\ttypeof target === \"function\"\n\nexport let isBoolean = (target: any): target is boolean =>\n\ttypeof target === \"boolean\"\n\nexport function isArrayIndex(value: string | number): value is number | string {\n\tconst n = +value\n\treturn Number.isInteger(n) && String(n) === value\n}\n\nexport let getProxyDraft = <T extends any>(value: T): ImmerState | null => {\n\tif (!isObjectish(value)) return null\n\treturn (value as {[DRAFT_STATE]: any})?.[DRAFT_STATE]\n}\n\n/*#__PURE__*/\nexport let latest = (state: ImmerState): any => state.copy_ || state.base_\n\nexport let getValue = <T extends object>(value: T): T => {\n\tconst proxyDraft = getProxyDraft(value)\n\treturn proxyDraft ? proxyDraft.copy_ ?? proxyDraft.base_ : value\n}\n\nexport let getFinalValue = (state: ImmerState): any =>\n\tstate.modified_ ? state.copy_ : state.base_\n\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: StrictMode) {\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\tif (isArray(base)) return Array[PROTOTYPE].slice.call(base)\n\n\tconst isPlain = isPlainObject(base)\n\n\tif (strict === true || (strict === \"class_only\" && !isPlain)) {\n\t\t// Perform a strict copy\n\t\tconst descriptors = O.getOwnPropertyDescriptors(base)\n\t\tdelete descriptors[DRAFT_STATE as any]\n\t\tlet keys = Reflect.ownKeys(descriptors)\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key: any = keys[i]\n\t\t\tconst desc = descriptors[key]\n\t\t\tif (desc[WRITABLE] === false) {\n\t\t\t\tdesc[WRITABLE] = true\n\t\t\t\tdesc[CONFIGURABLE] = true\n\t\t\t}\n\t\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t\t// with libraries that trap values, like mobx or vue\n\t\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\t\tif (desc.get || desc.set)\n\t\t\t\tdescriptors[key] = {\n\t\t\t\t\t[CONFIGURABLE]: true,\n\t\t\t\t\t[WRITABLE]: true, // could live with !!desc.set as well here...\n\t\t\t\t\t[ENUMERABLE]: desc[ENUMERABLE],\n\t\t\t\t\t[VALUE]: base[key]\n\t\t\t\t}\n\t\t}\n\t\treturn O.create(getPrototypeOf(base), descriptors)\n\t} else {\n\t\t// perform a sloppy copy\n\t\tconst proto = getPrototypeOf(base)\n\t\tif (proto !== null && isPlain) {\n\t\t\treturn {...base} // assumption: better inner class optimization than the assign below\n\t\t}\n\t\tconst obj = O.create(proto)\n\t\treturn O.assign(obj, base)\n\t}\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tO.defineProperties(obj, {\n\t\t\tset: dontMutateMethodOverride,\n\t\t\tadd: dontMutateMethodOverride,\n\t\t\tclear: dontMutateMethodOverride,\n\t\t\tdelete: dontMutateMethodOverride\n\t\t})\n\t}\n\tO.freeze(obj)\n\tif (deep)\n\t\t// See #590, don't recurse into non-enumerable / Symbol properties when freezing\n\t\t// So use Object.values (only string-like, enumerables) instead of each()\n\t\teach(\n\t\t\tobj,\n\t\t\t(_key, value) => {\n\t\t\t\tfreeze(value, true)\n\t\t\t},\n\t\t\tfalse\n\t\t)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nconst dontMutateMethodOverride = {\n\t[VALUE]: dontMutateFrozenCollections\n}\n\nexport function isFrozen(obj: any): boolean {\n\t// Fast path: primitives and null/undefined are always \"frozen\"\n\tif (obj === null || !isObjectish(obj)) return true\n\treturn O.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie,\n\tImmerScope,\n\tProxyArrayState\n} from \"../internal\"\n\nexport const PluginMapSet = \"MapSet\"\nexport const PluginPatches = \"Patches\"\nexport const PluginArrayMethods = \"ArrayMethods\"\n\nexport type PatchesPlugin = {\n\tgeneratePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\trootScope: ImmerScope\n\t): void\n\tgenerateReplacementPatches_(\n\t\tbase: any,\n\t\treplacement: any,\n\t\trootScope: ImmerScope\n\t): void\n\tapplyPatches_<T>(draft: T, patches: readonly Patch[]): T\n\tgetPath: (state: ImmerState) => PatchPath | null\n}\n\nexport type MapSetPlugin = {\n\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): [T, ImmerState]\n\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): [T, ImmerState]\n\tfixSetContents: (state: ImmerState) => void\n}\n\nexport type ArrayMethodsPlugin = {\n\tcreateMethodInterceptor: (state: ProxyArrayState, method: string) => Function\n\tisArrayOperationMethod: (method: string) => boolean\n\tisMutatingArrayMethod: (method: string) => boolean\n}\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: PatchesPlugin\n\tMapSet?: MapSetPlugin\n\tArrayMethods?: ArrayMethodsPlugin\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport let isPluginLoaded = <K extends keyof Plugins>(pluginKey: K): boolean =>\n\t!!plugins[pluginKey]\n\nexport let clearPlugin = <K extends keyof Plugins>(pluginKey: K): void => {\n\tdelete plugins[pluginKey]\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map\n\tcopy_: AnyMap | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tArchType,\n\tgetPlugin,\n\tPatchesPlugin,\n\tMapSetPlugin,\n\tisPluginLoaded,\n\tPluginMapSet,\n\tPluginPatches,\n\tArrayMethodsPlugin,\n\tPluginArrayMethods\n} from \"../internal\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tpatchPlugin_?: PatchesPlugin\n\tmapSetPlugin_?: MapSetPlugin\n\tarrayMethodsPlugin_?: ArrayMethodsPlugin\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n\thandledSet_: Set<any>\n\tprocessedForPatches_: Set<any>\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport let getCurrentScope = () => currentScope!\n\nlet createScope = (\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope => ({\n\tdrafts_: [],\n\tparent_,\n\timmer_,\n\t// Whenever the modified draft contains a draft from another scope, we\n\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\tcanAutoFreeze_: true,\n\tunfinalizedDrafts_: 0,\n\thandledSet_: new Set(),\n\tprocessedForPatches_: new Set(),\n\tmapSetPlugin_: isPluginLoaded(PluginMapSet)\n\t\t? getPlugin(PluginMapSet)\n\t\t: undefined,\n\tarrayMethodsPlugin_: isPluginLoaded(PluginArrayMethods)\n\t\t? getPlugin(PluginArrayMethods)\n\t\t: undefined\n})\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tscope.patchPlugin_ = getPlugin(PluginPatches) // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport let enterScope = (immer: Immer) =>\n\t(currentScope = createScope(currentScope, immer))\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tget,\n\tPatch,\n\tlatest,\n\tprepareCopy,\n\tgetFinalValue,\n\tgetValue,\n\tProxyArrayState\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t}\n\t\tconst {patchPlugin_} = scope\n\t\tif (patchPlugin_) {\n\t\t\tpatchPlugin_.generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft)\n\t}\n\n\tmaybeFreeze(scope, result, true)\n\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\tif (!state) {\n\t\tconst finalValue = handleValue(value, rootScope.handledSet_, rootScope)\n\t\treturn finalValue\n\t}\n\n\t// Never finalize drafts owned by another scope\n\tif (!isSameScope(state, rootScope)) {\n\t\treturn value\n\t}\n\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\treturn state.base_\n\t}\n\n\tif (!state.finalized_) {\n\t\t// Execute all registered draft finalization callbacks\n\t\tconst {callbacks_} = state\n\t\tif (callbacks_) {\n\t\t\twhile (callbacks_.length > 0) {\n\t\t\t\tconst callback = callbacks_.pop()!\n\t\t\t\tcallback(rootScope)\n\t\t\t}\n\t\t}\n\n\t\tgeneratePatchesAndFinalize(state, rootScope)\n\t}\n\n\t// By now the root copy has been fully updated throughout its tree\n\treturn state.copy_\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n\nfunction markStateFinalized(state: ImmerState) {\n\tstate.finalized_ = true\n\tstate.scope_.unfinalizedDrafts_--\n}\n\nlet isSameScope = (state: ImmerState, rootScope: ImmerScope) =>\n\tstate.scope_ === rootScope\n\n// A reusable empty array to avoid allocations\nconst EMPTY_LOCATIONS_RESULT: (string | symbol | number)[] = []\n\n// Updates all references to a draft in its parent to the finalized value.\n// This handles cases where the same draft appears multiple times in the parent, or has been moved around.\nexport function updateDraftInParent(\n\tparent: ImmerState,\n\tdraftValue: any,\n\tfinalizedValue: any,\n\toriginalKey?: string | number | symbol\n): void {\n\tconst parentCopy = latest(parent)\n\tconst parentType = parent.type_\n\n\t// Fast path: Check if draft is still at original key\n\tif (originalKey !== undefined) {\n\t\tconst currentValue = get(parentCopy, originalKey, parentType)\n\t\tif (currentValue === draftValue) {\n\t\t\t// Still at original location, just update it\n\t\t\tset(parentCopy, originalKey, finalizedValue, parentType)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Slow path: Build reverse mapping of all children\n\t// to their indices in the parent, so that we can\n\t// replace all locations where this draft appears.\n\t// We only have to build this once per parent.\n\tif (!parent.draftLocations_) {\n\t\tconst draftLocations = (parent.draftLocations_ = new Map())\n\n\t\t// Use `each` which works on Arrays, Maps, and Objects\n\t\teach(parentCopy, (key, value) => {\n\t\t\tif (isDraft(value)) {\n\t\t\t\tconst keys = draftLocations.get(value) || []\n\t\t\t\tkeys.push(key)\n\t\t\t\tdraftLocations.set(value, keys)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Look up all locations where this draft appears\n\tconst locations =\n\t\tparent.draftLocations_.get(draftValue) ?? EMPTY_LOCATIONS_RESULT\n\n\t// Update all locations\n\tfor (const location of locations) {\n\t\tset(parentCopy, location, finalizedValue, parentType)\n\t}\n}\n\n// Register a callback to finalize a child draft when the parent draft is finalized.\n// This assumes there is a parent -> child relationship between the two drafts,\n// and we have a key to locate the child in the parent.\nexport function registerChildFinalizationCallback(\n\tparent: ImmerState,\n\tchild: ImmerState,\n\tkey: string | number | symbol\n) {\n\tparent.callbacks_.push(function childCleanup(rootScope) {\n\t\tconst state: ImmerState = child\n\n\t\t// Can only continue if this is a draft owned by this scope\n\t\tif (!state || !isSameScope(state, rootScope)) {\n\t\t\treturn\n\t\t}\n\n\t\t// Handle potential set value finalization first\n\t\trootScope.mapSetPlugin_?.fixSetContents(state)\n\n\t\tconst finalizedValue = getFinalValue(state)\n\n\t\t// Update all locations in the parent that referenced this draft\n\t\tupdateDraftInParent(parent, state.draft_ ?? state, finalizedValue, key)\n\n\t\tgeneratePatchesAndFinalize(state, rootScope)\n\t})\n}\n\nfunction generatePatchesAndFinalize(state: ImmerState, rootScope: ImmerScope) {\n\tconst shouldFinalize =\n\t\tstate.modified_ &&\n\t\t!state.finalized_ &&\n\t\t(state.type_ === ArchType.Set ||\n\t\t\t(state.type_ === ArchType.Array &&\n\t\t\t\t(state as ProxyArrayState).allIndicesReassigned_) ||\n\t\t\t(state.assigned_?.size ?? 0) > 0)\n\n\tif (shouldFinalize) {\n\t\tconst {patchPlugin_} = rootScope\n\t\tif (patchPlugin_) {\n\t\t\tconst basePath = patchPlugin_!.getPath(state)\n\n\t\t\tif (basePath) {\n\t\t\t\tpatchPlugin_!.generatePatches_(state, basePath, rootScope)\n\t\t\t}\n\t\t}\n\n\t\tmarkStateFinalized(state)\n\t}\n}\n\nexport function handleCrossReference(\n\ttarget: ImmerState,\n\tkey: string | number | symbol,\n\tvalue: any\n) {\n\tconst {scope_} = target\n\t// Check if value is a draft from this scope\n\tif (isDraft(value)) {\n\t\tconst state: ImmerState = value[DRAFT_STATE]\n\t\tif (isSameScope(state, scope_)) {\n\t\t\t// Register callback to update this location when the draft finalizes\n\n\t\t\tstate.callbacks_.push(function crossReferenceCleanup() {\n\t\t\t\t// Update the target location with finalized value\n\t\t\t\tprepareCopy(target)\n\n\t\t\t\tconst finalizedValue = getFinalValue(state)\n\n\t\t\t\tupdateDraftInParent(target, value, finalizedValue, key)\n\t\t\t})\n\t\t}\n\t} else if (isDraftable(value)) {\n\t\t// Handle non-draft objects that might contain drafts\n\t\ttarget.callbacks_.push(function nestedDraftCleanup() {\n\t\t\tconst targetCopy = latest(target)\n\n\t\t\t// For Sets, check if value is still in the set\n\t\t\tif (target.type_ === ArchType.Set) {\n\t\t\t\tif (targetCopy.has(value)) {\n\t\t\t\t\t// Process the value to replace any nested drafts\n\t\t\t\t\thandleValue(value, scope_.handledSet_, scope_)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Maps/objects\n\t\t\t\tif (get(targetCopy, key, target.type_) === value) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tscope_.drafts_.length > 1 &&\n\t\t\t\t\t\t((target as Exclude<ImmerState, SetState>).assigned_!.get(key) ??\n\t\t\t\t\t\t\tfalse) === true &&\n\t\t\t\t\t\ttarget.copy_\n\t\t\t\t\t) {\n\t\t\t\t\t\t// This might be a non-draft value that has drafts\n\t\t\t\t\t\t// inside. We do need to recurse here to handle those.\n\t\t\t\t\t\thandleValue(\n\t\t\t\t\t\t\tget(target.copy_, key, target.type_),\n\t\t\t\t\t\t\tscope_.handledSet_,\n\t\t\t\t\t\t\tscope_\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nexport function handleValue(\n\ttarget: any,\n\thandledSet: Set<any>,\n\trootScope: ImmerScope\n) {\n\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t// This benefits especially adding large data tree's without further processing.\n\t\t// See add-data.js perf test\n\t\treturn target\n\t}\n\n\t// Skip if already handled, frozen, or not draftable\n\tif (\n\t\tisDraft(target) ||\n\t\thandledSet.has(target) ||\n\t\t!isDraftable(target) ||\n\t\tisFrozen(target)\n\t) {\n\t\treturn target\n\t}\n\n\thandledSet.add(target)\n\n\t// Process ALL properties/entries\n\teach(target, (key, value) => {\n\t\tif (isDraft(value)) {\n\t\t\tconst state: ImmerState = value[DRAFT_STATE]\n\t\t\tif (isSameScope(state, rootScope)) {\n\t\t\t\t// Replace draft with finalized value\n\n\t\t\t\tconst updatedValue = getFinalValue(state)\n\n\t\t\t\tset(target, key, updatedValue, target.type_)\n\n\t\t\t\tmarkStateFinalized(state)\n\t\t\t}\n\t\t} else if (isDraftable(value)) {\n\t\t\t// Recursively handle nested values\n\t\t\thandleValue(value, handledSet, rootScope)\n\t\t}\n\t})\n\n\treturn target\n}\n","import {\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\thandleCrossReference,\n\tWRITABLE,\n\tCONFIGURABLE,\n\tENUMERABLE,\n\tVALUE,\n\tisArray,\n\tisArrayIndex\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ArchType.Object\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ArchType.Array\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n\toperationMethod?: string\n\tallIndicesReassigned_?: boolean\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): [Drafted<T, ProxyState>, ProxyState] {\n\tconst baseIsArray = isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: baseIsArray ? ArchType.Array : (ArchType.Object as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\t// actually instantiated in `prepareCopy()`\n\t\tassigned_: undefined,\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false,\n\t\t// `callbacks` actually gets assigned in `createProxy`\n\t\tcallbacks_: undefined as any\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (baseIsArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn [proxy as any, state]\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tlet arrayPlugin = state.scope_.arrayMethodsPlugin_\n\t\tconst isArrayWithStringProp =\n\t\t\tstate.type_ === ArchType.Array && typeof prop === \"string\"\n\t\t// Intercept array methods so that we can override\n\t\t// behavior and skip proxy creation for perf\n\t\tif (isArrayWithStringProp) {\n\t\t\tif (arrayPlugin?.isArrayOperationMethod(prop)) {\n\t\t\t\treturn arrayPlugin.createMethodInterceptor(state, prop)\n\t\t\t}\n\t\t}\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop, state.type_)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\n\t\t// During mutating array operations, defer proxy creation for array elements\n\t\t// This optimization avoids creating unnecessary proxies during sort/reverse\n\t\tif (\n\t\t\tisArrayWithStringProp &&\n\t\t\t(state as ProxyArrayState).operationMethod &&\n\t\t\tarrayPlugin?.isMutatingArrayMethod(\n\t\t\t\t(state as ProxyArrayState).operationMethod!\n\t\t\t) &&\n\t\t\tisArrayIndex(prop)\n\t\t) {\n\t\t\t// Return raw value during mutating operations, create proxy only if modified\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\t// Ensure array keys are always numbers\n\t\t\tconst childKey = state.type_ === ArchType.Array ? +(prop as string) : prop\n\t\t\tconst childDraft = createProxy(state.scope_, value, state, childKey)\n\n\t\t\treturn (state.copy_![childKey] = childDraft)\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_!.set(prop, false)\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (\n\t\t\t\tis(value, current) &&\n\t\t\t\t(value !== undefined || has(state.base_, prop, state.type_))\n\t\t\t)\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// special case: NaN\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_!.set(prop, true)\n\n\t\thandleCrossReference(state, prop, value)\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\tprepareCopy(state)\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_!.set(prop, false)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tstate.assigned_!.delete(prop)\n\t\t}\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\t[WRITABLE]: true,\n\t\t\t[CONFIGURABLE]: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\t[ENUMERABLE]: desc[ENUMERABLE],\n\t\t\t[VALUE]: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\n// Use `for..in` instead of `each` to work around a weird\n// prod test suite issue\nfor (let key in objectTraps) {\n\tlet fn = objectTraps[key as keyof typeof objectTraps] as Function\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\tconst args = arguments\n\t\targs[0] = args[0][0]\n\t\treturn fn.apply(this, args)\n\t}\n}\narrayTraps.deleteProperty = function(state, prop) {\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? VALUE in desc\n\t\t\t? desc[VALUE]\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: ImmerState) {\n\tif (!state.copy_) {\n\t\t// Actually create the `assigned_` map now that we\n\t\t// know this is a modified draft.\n\t\tstate.assigned_ = new Map()\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent,\n\tImmerScope,\n\tregisterChildFinalizationCallback,\n\tArchType,\n\tMapSetPlugin,\n\tAnyMap,\n\tAnySet,\n\tisObjectish,\n\tisFunction,\n\tisBoolean,\n\tPluginMapSet,\n\tPluginPatches\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport type StrictMode = boolean | \"class_only\"\n\nexport class Immer implements ProducersFns {\n\tautoFreeze_: boolean = true\n\tuseStrictShallowCopy_: StrictMode = false\n\tuseStrictIteration_: boolean = false\n\n\tconstructor(config?: {\n\t\tautoFreeze?: boolean\n\t\tuseStrictShallowCopy?: StrictMode\n\t\tuseStrictIteration?: boolean\n\t}) {\n\t\tif (isBoolean(config?.autoFreeze)) this.setAutoFreeze(config!.autoFreeze)\n\t\tif (isBoolean(config?.useStrictShallowCopy))\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t\tif (isBoolean(config?.useStrictIteration))\n\t\t\tthis.setUseStrictIteration(config!.useStrictIteration)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (isFunction(base) && !isFunction(recipe)) {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (!isFunction(recipe)) die(6)\n\t\tif (patchListener !== undefined && !isFunction(patchListener)) die(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(scope, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || !isObjectish(base)) {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(PluginPatches).generateReplacementPatches_(base, result, {\n\t\t\t\t\tpatches_: p,\n\t\t\t\t\tinversePatches_: ip\n\t\t\t\t} as ImmerScope) // dummy scope\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(1, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// curried invocation\n\t\tif (isFunction(base)) {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(scope, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (!state || !state.isManual_) die(9)\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to enable strict shallow copy.\n\t *\n\t * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n\t */\n\tsetUseStrictShallowCopy(value: StrictMode) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\t/**\n\t * Pass false to use faster iteration that skips non-enumerable properties\n\t * but still handles symbols for compatibility.\n\t *\n\t * By default, strict iteration is enabled (includes all own properties).\n\t */\n\tsetUseStrictIteration(value: boolean) {\n\t\tthis.useStrictIteration_ = value\n\t}\n\n\tshouldUseStrictIteration(): boolean {\n\t\treturn this.useStrictIteration_\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: readonly Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(PluginPatches).applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\trootScope: ImmerScope,\n\tvalue: T,\n\tparent?: ImmerState,\n\tkey?: string | number | symbol\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\t// returning a tuple here lets us skip a proxy access\n\t// to DRAFT_STATE later\n\tconst [draft, state] = isMap(value)\n\t\t? getPlugin(PluginMapSet).proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(PluginMapSet).proxySet_(value, parent)\n\t\t: createProxyProxy(value, parent)\n\n\tconst scope = parent?.scope_ ?? getCurrentScope()\n\tscope.drafts_.push(draft)\n\n\t// Ensure the parent callbacks are passed down so we actually\n\t// track all callbacks added throughout the tree\n\tstate.callbacks_ = parent?.callbacks_ ?? []\n\tstate.key_ = key\n\n\tif (parent && key !== undefined) {\n\t\tregisterChildFinalizationCallback(parent, state, key)\n\t} else {\n\t\t// It's a root draft, register it with the scope\n\t\tstate.callbacks_.push(function rootDraftCleanup(rootScope) {\n\t\t\trootScope.mapSetPlugin_?.fixSetContents(state)\n\n\t\t\tconst {patchPlugin_} = rootScope\n\n\t\t\tif (state.modified_ && patchPlugin_) {\n\t\t\t\tpatchPlugin_.generatePatches_(state, [], rootScope)\n\t\t\t}\n\t\t})\n\t}\n\n\treturn draft as any\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tlet strict = true // Default to strict for compatibility\n\tif (state) {\n\t\tif (!state.modified_) return state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t\tstrict = state.scope_.immer_.shouldUseStrictIteration()\n\t} else {\n\t\tcopy = shallowCopy(value, true)\n\t}\n\t// recurse\n\teach(\n\t\tcopy,\n\t\t(key, childValue) => {\n\t\t\tset(copy, key, currentImpl(childValue))\n\t\t},\n\t\tstrict\n\t)\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\treturn copy\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tProxyArrayState,\n\tMapState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tgetPrototypeOf,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tArchType,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING,\n\terrors,\n\tDRAFT_STATE,\n\tgetProxyDraft,\n\tImmerScope,\n\tisObjectish,\n\tisFunction,\n\tCONSTRUCTOR,\n\tPluginPatches,\n\tisArray,\n\tPROTOTYPE\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst errorOffset = 16\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\terrors.push(\n\t\t\t'Sets cannot have \"replace\" patches.',\n\t\t\tfunction(op: string) {\n\t\t\t\treturn \"Unsupported patch operation: \" + op\n\t\t\t},\n\t\t\tfunction(path: string) {\n\t\t\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t\t\t},\n\t\t\t\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t\t)\n\t}\n\n\tfunction getPath(state: ImmerState, path: PatchPath = []): PatchPath | null {\n\t\t// Step 1: Check if state has a stored key\n\t\tif (state.key_ !== undefined) {\n\t\t\t// Step 2: Validate the key is still valid in parent\n\n\t\t\tconst parentCopy = state.parent_!.copy_ ?? state.parent_!.base_\n\t\t\tconst proxyDraft = getProxyDraft(get(parentCopy, state.key_!))\n\t\t\tconst valueAtKey = get(parentCopy, state.key_!)\n\n\t\t\tif (valueAtKey === undefined) {\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\t// Check if the value at the key is still related to this draft\n\t\t\t// It should be either the draft itself, the base, or the copy\n\t\t\tif (\n\t\t\t\tvalueAtKey !== state.draft_ &&\n\t\t\t\tvalueAtKey !== state.base_ &&\n\t\t\t\tvalueAtKey !== state.copy_\n\t\t\t) {\n\t\t\t\treturn null // Value was replaced with something else\n\t\t\t}\n\t\t\tif (proxyDraft != null && proxyDraft.base_ !== state.base_) {\n\t\t\t\treturn null // Different draft\n\t\t\t}\n\n\t\t\t// Step 3: Handle Set case specially\n\t\t\tconst isSet = state.parent_!.type_ === ArchType.Set\n\t\t\tlet key: string | number\n\n\t\t\tif (isSet) {\n\t\t\t\t// For Sets, find the index in the drafts_ map\n\t\t\t\tconst setParent = state.parent_ as SetState\n\t\t\t\tkey = Array.from(setParent.drafts_.keys()).indexOf(state.key_)\n\t\t\t} else {\n\t\t\t\tkey = state.key_ as string | number\n\t\t\t}\n\n\t\t\t// Step 4: Validate key still exists in parent\n\t\t\tif (!((isSet && parentCopy.size > key) || has(parentCopy, key))) {\n\t\t\t\treturn null // Key deleted\n\t\t\t}\n\n\t\t\t// Step 5: Add key to path\n\t\t\tpath.push(key)\n\t\t}\n\n\t\t// Step 6: Recurse to parent if exists\n\t\tif (state.parent_) {\n\t\t\treturn getPath(state.parent_, path)\n\t\t}\n\n\t\t// Step 7: At root - reverse path and validate\n\t\tpath.reverse()\n\n\t\ttry {\n\t\t\t// Validate path can be resolved from ROOT\n\t\t\tresolvePath(state.copy_, path)\n\t\t} catch (e) {\n\t\t\treturn null // Path invalid\n\t\t}\n\n\t\treturn path\n\t}\n\n\t// NEW: Add resolvePath helper function\n\tfunction resolvePath(base: any, path: PatchPath): any {\n\t\tlet current = base\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst key = path[i]\n\t\t\tcurrent = get(current, key)\n\t\t\tif (!isObjectish(current) || current === null) {\n\t\t\t\tthrow new Error(`Cannot resolve path at '${path.join(\"/\")}'`)\n\t\t\t}\n\t\t}\n\t\treturn current\n\t}\n\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tscope: ImmerScope\n\t): void {\n\t\tif (state.scope_.processedForPatches_.has(state)) {\n\t\t\treturn\n\t\t}\n\n\t\tstate.scope_.processedForPatches_.add(state)\n\n\t\tconst {patches_, inversePatches_} = scope\n\n\t\tswitch (state.type_) {\n\t\t\tcase ArchType.Object:\n\t\t\tcase ArchType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t\tcase ArchType.Array:\n\t\t\t\treturn generateArrayPatches(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t\tcase ArchType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\tconst allReassigned = state.allIndicesReassigned_ === true\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tconst copiedItem = copy_[i]\n\t\t\tconst baseItem = base_[i]\n\n\t\t\tconst isAssigned = allReassigned || assigned_?.get(i.toString())\n\t\t\tif (isAssigned && copiedItem !== baseItem) {\n\t\t\t\tconst childState = copiedItem?.[DRAFT_STATE]\n\t\t\t\tif (childState && childState.modified_) {\n\t\t\t\t\t// Skip - let the child generate its own patches\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copiedItem)\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(baseItem)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tfor (let i = copy_.length - 1; base_.length <= i; --i) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tinversePatches.push({\n\t\t\t\top: REMOVE,\n\t\t\t\tpath\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_, type_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key, type_)\n\t\t\tconst value = get(copy_!, key, type_)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(\n\t\t\t\top === REMOVE\n\t\t\t\t\t? {op, path}\n\t\t\t\t\t: {op, path, value: clonePatchValueIfNeeded(value)}\n\t\t\t)\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tscope: ImmerScope\n\t): void {\n\t\tconst {patches_, inversePatches_} = scope\n\t\tpatches_!.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches_!.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: readonly Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tlet p = path[i]\n\t\t\t\tif (typeof p !== \"string\" && typeof p !== \"number\") {\n\t\t\t\t\tp = \"\" + p\n\t\t\t\t}\n\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === ArchType.Object || parentType === ArchType.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === CONSTRUCTOR)\n\t\t\t\t)\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tif (isFunction(base) && p === PROTOTYPE) die(errorOffset + 3)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (!isObjectish(base)) die(errorOffset + 2, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\tdie(errorOffset)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(errorOffset + 1, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(PluginPatches, {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_,\n\t\tgetPath\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tdie,\n\tArchType,\n\teach,\n\tgetValue,\n\tPluginMapSet,\n\thandleCrossReference\n} from \"../internal\"\n\nexport function enableMapSet() {\n\tclass DraftMap extends Map {\n\t\t[DRAFT_STATE]: MapState\n\n\t\tconstructor(target: AnyMap, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false,\n\t\t\t\tcallbacks_: []\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tset(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\thandleCrossReference(state, key, value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tforEach(cb: (value: any, key: any, self: any) => void, thisArg?: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tget(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_, value, state, key)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.entries()\n\t\t}\n\t}\n\n\tfunction proxyMap_<T extends AnyMap>(\n\t\ttarget: T,\n\t\tparent?: ImmerState\n\t): [T, MapState] {\n\t\t// @ts-ignore\n\t\tconst map = new DraftMap(target, parent)\n\t\treturn [map as any, map[DRAFT_STATE]]\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tclass DraftSet extends Set {\n\t\t[DRAFT_STATE]: SetState\n\t\tconstructor(target: AnySet, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tcallbacks_: []\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tadd(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t\thandleCrossReference(state, value, value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tforEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\t}\n\tfunction proxySet_<T extends AnySet>(\n\t\ttarget: T,\n\t\tparent?: ImmerState\n\t): [T, SetState] {\n\t\t// @ts-ignore\n\t\tconst set = new DraftSet(target, parent)\n\t\treturn [set as any, set[DRAFT_STATE]]\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_, value, state, value)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tfunction fixSetContents(target: ImmerState) {\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// To preserve insertion order in all cases we then clear the set\n\t\tif (target.type_ === ArchType.Set && target.copy_) {\n\t\t\tconst copy = new Set(target.copy_)\n\t\t\ttarget.copy_.clear()\n\t\t\tcopy.forEach(value => {\n\t\t\t\ttarget.copy_!.add(getValue(value))\n\t\t\t})\n\t\t}\n\t}\n\n\tloadPlugin(PluginMapSet, {proxyMap_, proxySet_, fixSetContents})\n}\n","import {\n\tPluginArrayMethods,\n\tlatest,\n\tloadPlugin,\n\tmarkChanged,\n\tprepareCopy,\n\tProxyArrayState\n} from \"../internal\"\n\n/**\n * Methods that directly modify the array in place.\n * These operate on the copy without creating per-element proxies:\n * - `push`, `pop`: Add/remove from end\n * - `shift`, `unshift`: Add/remove from start (marks all indices reassigned)\n * - `splice`: Add/remove at arbitrary position (marks all indices reassigned)\n * - `reverse`, `sort`: Reorder elements (marks all indices reassigned)\n */\ntype MutatingArrayMethod =\n\t| \"push\"\n\t| \"pop\"\n\t| \"shift\"\n\t| \"unshift\"\n\t| \"splice\"\n\t| \"reverse\"\n\t| \"sort\"\n\n/**\n * Methods that read from the array without modifying it.\n * These fall into distinct categories based on return semantics:\n *\n * **Subset operations** (return drafts - mutations propagate):\n * - `filter`, `slice`: Return array of draft proxies\n * - `find`, `findLast`: Return single draft proxy or undefined\n *\n * **Transform operations** (return base values - mutations don't track):\n * - `concat`, `flat`: Create new structures, not subsets of original\n *\n * **Primitive-returning** (no draft needed):\n * - `findIndex`, `findLastIndex`, `indexOf`, `lastIndexOf`: Return numbers\n * - `some`, `every`, `includes`: Return booleans\n * - `join`, `toString`, `toLocaleString`: Return strings\n */\ntype NonMutatingArrayMethod =\n\t| \"filter\"\n\t| \"slice\"\n\t| \"concat\"\n\t| \"flat\"\n\t| \"find\"\n\t| \"findIndex\"\n\t| \"findLast\"\n\t| \"findLastIndex\"\n\t| \"some\"\n\t| \"every\"\n\t| \"indexOf\"\n\t| \"lastIndexOf\"\n\t| \"includes\"\n\t| \"join\"\n\t| \"toString\"\n\t| \"toLocaleString\"\n\n/** Union of all array operation methods handled by the plugin. */\nexport type ArrayOperationMethod = MutatingArrayMethod | NonMutatingArrayMethod\n\n/**\n * Enables optimized array method handling for Immer drafts.\n *\n * This plugin overrides array methods to avoid unnecessary Proxy creation during iteration,\n * significantly improving performance for array-heavy operations.\n *\n * **Mutating methods** (push, pop, shift, unshift, splice, sort, reverse):\n * Operate directly on the copy without creating per-element proxies.\n *\n * **Non-mutating methods** fall into categories:\n * - **Subset operations** (filter, slice, find, findLast): Return draft proxies - mutations track\n * - **Transform operations** (concat, flat): Return base values - mutations don't track\n * - **Primitive-returning** (indexOf, includes, some, every, etc.): Return primitives\n *\n * **Important**: Callbacks for overridden methods receive base values, not drafts.\n * This is the core performance optimization.\n *\n * @example\n * ```ts\n * import { enableArrayMethods, produce } from \"immer\"\n *\n * enableArrayMethods()\n *\n * const next = produce(state, draft => {\n *   // Optimized - no proxy creation per element\n *   draft.items.sort((a, b) => a.value - b.value)\n *\n *   // filter returns drafts - mutations propagate\n *   const filtered = draft.items.filter(x => x.value > 5)\n *   filtered[0].value = 999 // Affects draft.items[originalIndex]\n * })\n * ```\n *\n * @see https://immerjs.github.io/immer/array-methods\n */\nexport function enableArrayMethods() {\n\tconst SHIFTING_METHODS = new Set<MutatingArrayMethod>([\"shift\", \"unshift\"])\n\n\tconst QUEUE_METHODS = new Set<MutatingArrayMethod>([\"push\", \"pop\"])\n\n\tconst RESULT_RETURNING_METHODS = new Set<MutatingArrayMethod>([\n\t\t...QUEUE_METHODS,\n\t\t...SHIFTING_METHODS\n\t])\n\n\tconst REORDERING_METHODS = new Set<MutatingArrayMethod>([\"reverse\", \"sort\"])\n\n\t// Optimized method detection using array-based lookup\n\tconst MUTATING_METHODS = new Set<MutatingArrayMethod>([\n\t\t...RESULT_RETURNING_METHODS,\n\t\t...REORDERING_METHODS,\n\t\t\"splice\"\n\t])\n\n\tconst FIND_METHODS = new Set<NonMutatingArrayMethod>([\"find\", \"findLast\"])\n\n\tconst NON_MUTATING_METHODS = new Set<NonMutatingArrayMethod>([\n\t\t\"filter\",\n\t\t\"slice\",\n\t\t\"concat\",\n\t\t\"flat\",\n\t\t...FIND_METHODS,\n\t\t\"findIndex\",\n\t\t\"findLastIndex\",\n\t\t\"some\",\n\t\t\"every\",\n\t\t\"indexOf\",\n\t\t\"lastIndexOf\",\n\t\t\"includes\",\n\t\t\"join\",\n\t\t\"toString\",\n\t\t\"toLocaleString\"\n\t])\n\n\t// Type guard for method detection\n\tfunction isMutatingArrayMethod(\n\t\tmethod: string\n\t): method is MutatingArrayMethod {\n\t\treturn MUTATING_METHODS.has(method as any)\n\t}\n\n\tfunction isNonMutatingArrayMethod(\n\t\tmethod: string\n\t): method is NonMutatingArrayMethod {\n\t\treturn NON_MUTATING_METHODS.has(method as any)\n\t}\n\n\tfunction isArrayOperationMethod(\n\t\tmethod: string\n\t): method is ArrayOperationMethod {\n\t\treturn isMutatingArrayMethod(method) || isNonMutatingArrayMethod(method)\n\t}\n\n\tfunction enterOperation(\n\t\tstate: ProxyArrayState,\n\t\tmethod: ArrayOperationMethod\n\t) {\n\t\tstate.operationMethod = method\n\t}\n\n\tfunction exitOperation(state: ProxyArrayState) {\n\t\tstate.operationMethod = undefined\n\t}\n\n\t// Shared utility functions for array method handlers\n\tfunction executeArrayMethod<T>(\n\t\tstate: ProxyArrayState,\n\t\toperation: () => T,\n\t\tmarkLength = true\n\t): T {\n\t\tprepareCopy(state)\n\t\tconst result = operation()\n\t\tmarkChanged(state)\n\t\tif (markLength) state.assigned_!.set(\"length\", true)\n\t\treturn result\n\t}\n\n\tfunction markAllIndicesReassigned(state: ProxyArrayState) {\n\t\tstate.allIndicesReassigned_ = true\n\t}\n\n\tfunction normalizeSliceIndex(index: number, length: number): number {\n\t\tif (index < 0) {\n\t\t\treturn Math.max(length + index, 0)\n\t\t}\n\t\treturn Math.min(index, length)\n\t}\n\n\t/**\n\t * Handles mutating operations that add/remove elements (push, pop, shift, unshift, splice).\n\t *\n\t * Operates directly on `state.copy_` without creating per-element proxies.\n\t * For shifting methods (shift, unshift), marks all indices as reassigned since\n\t * indices shift.\n\t *\n\t * @returns For push/pop/shift/unshift: the native method result. For others: the draft.\n\t */\n\tfunction handleSimpleOperation(\n\t\tstate: ProxyArrayState,\n\t\tmethod: string,\n\t\targs: any[]\n\t) {\n\t\treturn executeArrayMethod(state, () => {\n\t\t\tconst result = (state.copy_! as any)[method](...args)\n\n\t\t\t// Handle index reassignment for shifting methods\n\t\t\tif (SHIFTING_METHODS.has(method as MutatingArrayMethod)) {\n\t\t\t\tmarkAllIndicesReassigned(state)\n\t\t\t}\n\n\t\t\t// Return appropriate value based on method\n\t\t\treturn RESULT_RETURNING_METHODS.has(method as MutatingArrayMethod)\n\t\t\t\t? result\n\t\t\t\t: state.draft_\n\t\t})\n\t}\n\n\t/**\n\t * Handles reordering operations (reverse, sort) that change element order.\n\t *\n\t * Operates directly on `state.copy_` and marks all indices as reassigned\n\t * since element positions change. Does not mark length as changed since\n\t * these operations preserve array length.\n\t *\n\t * @returns The draft proxy for method chaining.\n\t */\n\tfunction handleReorderingOperation(\n\t\tstate: ProxyArrayState,\n\t\tmethod: string,\n\t\targs: any[]\n\t) {\n\t\treturn executeArrayMethod(\n\t\t\tstate,\n\t\t\t() => {\n\t\t\t\t;(state.copy_! as any)[method](...args)\n\t\t\t\tmarkAllIndicesReassigned(state)\n\t\t\t\treturn state.draft_\n\t\t\t},\n\t\t\tfalse\n\t\t) // Don't mark length as changed\n\t}\n\n\t/**\n\t * Creates an interceptor function for a specific array method.\n\t *\n\t * The interceptor wraps array method calls to:\n\t * 1. Set `state.operationMethod` flag during execution (allows proxy `get` trap\n\t *    to detect we're inside an optimized method and skip proxy creation)\n\t * 2. Route to appropriate handler based on method type\n\t * 3. Clean up the operation flag in `finally` block\n\t *\n\t * The `operationMethod` flag is the key mechanism that enables the proxy's `get`\n\t * trap to return base values instead of creating nested proxies during iteration.\n\t *\n\t * @param state - The proxy array state\n\t * @param originalMethod - Name of the array method being intercepted\n\t * @returns Interceptor function that handles the method call\n\t */\n\tfunction createMethodInterceptor(\n\t\tstate: ProxyArrayState,\n\t\toriginalMethod: string\n\t) {\n\t\treturn function interceptedMethod(...args: any[]) {\n\t\t\t// Enter operation mode - this flag tells the proxy's get trap to return\n\t\t\t// base values instead of creating nested proxies during iteration\n\t\t\tconst method = originalMethod as ArrayOperationMethod\n\t\t\tenterOperation(state, method)\n\n\t\t\ttry {\n\t\t\t\t// Check if this is a mutating method\n\t\t\t\tif (isMutatingArrayMethod(method)) {\n\t\t\t\t\t// Direct method dispatch - no configuration lookup needed\n\t\t\t\t\tif (RESULT_RETURNING_METHODS.has(method)) {\n\t\t\t\t\t\treturn handleSimpleOperation(state, method, args)\n\t\t\t\t\t}\n\t\t\t\t\tif (REORDERING_METHODS.has(method)) {\n\t\t\t\t\t\treturn handleReorderingOperation(state, method, args)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (method === \"splice\") {\n\t\t\t\t\t\tconst res = executeArrayMethod(state, () =>\n\t\t\t\t\t\t\tstate.copy_!.splice(...(args as [number, number, ...any[]]))\n\t\t\t\t\t\t)\n\t\t\t\t\t\tmarkAllIndicesReassigned(state)\n\t\t\t\t\t\treturn res\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Handle non-mutating methods\n\t\t\t\t\treturn handleNonMutatingOperation(state, method, args)\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\t// Always exit operation mode - must be in finally to handle exceptions\n\t\t\t\texitOperation(state)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handles non-mutating array methods with different return semantics.\n\t *\n\t * **Subset operations** return draft proxies for mutation tracking:\n\t * - `filter`, `slice`: Return `state.draft_[i]` for each selected element\n\t * - `find`, `findLast`: Return `state.draft_[i]` for the found element\n\t *\n\t * This allows mutations on returned elements to propagate back to the draft:\n\t * ```ts\n\t * const filtered = draft.items.filter(x => x.value > 5)\n\t * filtered[0].value = 999 // Mutates draft.items[originalIndex]\n\t * ```\n\t *\n\t * **Transform operations** return base values (no draft tracking):\n\t * - `concat`, `flat`: These create NEW arrays rather than selecting subsets.\n\t *   Since the result structure differs from the original, tracking mutations\n\t *   back to specific draft indices would be impractical/impossible.\n\t *\n\t * **Primitive operations** return the native result directly:\n\t * - `indexOf`, `includes`, `some`, `every`, `join`, etc.\n\t *\n\t * @param state - The proxy array state\n\t * @param method - The non-mutating method name\n\t * @param args - Arguments passed to the method\n\t * @returns Drafts for subset operations, base values for transforms, primitives otherwise\n\t */\n\tfunction handleNonMutatingOperation(\n\t\tstate: ProxyArrayState,\n\t\tmethod: NonMutatingArrayMethod,\n\t\targs: any[]\n\t) {\n\t\tconst source = latest(state)\n\n\t\t// Methods that return arrays with selected items - need to return drafts\n\t\tif (method === \"filter\") {\n\t\t\tconst predicate = args[0]\n\t\t\tconst result: any[] = []\n\n\t\t\t// First pass: call predicate on base values to determine which items pass\n\t\t\tfor (let i = 0; i < source.length; i++) {\n\t\t\t\tif (predicate(source[i], i, source)) {\n\t\t\t\t\t// Only create draft for items that passed the predicate\n\t\t\t\t\tresult.push(state.draft_[i])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result\n\t\t}\n\n\t\tif (FIND_METHODS.has(method)) {\n\t\t\tconst predicate = args[0]\n\t\t\tconst isForward = method === \"find\"\n\t\t\tconst step = isForward ? 1 : -1\n\t\t\tconst start = isForward ? 0 : source.length - 1\n\n\t\t\tfor (let i = start; i >= 0 && i < source.length; i += step) {\n\t\t\t\tif (predicate(source[i], i, source)) {\n\t\t\t\t\treturn state.draft_[i]\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (method === \"slice\") {\n\t\t\tconst rawStart = args[0] ?? 0\n\t\t\tconst rawEnd = args[1] ?? source.length\n\n\t\t\t// Normalize negative indices\n\t\t\tconst start = normalizeSliceIndex(rawStart, source.length)\n\t\t\tconst end = normalizeSliceIndex(rawEnd, source.length)\n\n\t\t\tconst result: any[] = []\n\n\t\t\t// Return drafts for items in the slice range\n\t\t\tfor (let i = start; i < end; i++) {\n\t\t\t\tresult.push(state.draft_[i])\n\t\t\t}\n\n\t\t\treturn result\n\t\t}\n\n\t\t// For other methods, call on base array directly:\n\t\t// - indexOf, includes, join, toString: Return primitives, no draft needed\n\t\t// - concat, flat: Return NEW arrays (not subsets). Elements are base values.\n\t\t//   This is intentional - concat/flat create new data structures rather than\n\t\t//   selecting subsets of the original, making draft tracking impractical.\n\t\treturn source[method as keyof typeof Array.prototype](...args)\n\t}\n\n\tloadPlugin(PluginArrayMethods, {\n\t\tcreateMethodInterceptor,\n\t\tisArrayOperationMethod,\n\t\tisMutatingArrayMethod\n\t})\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA,eAAAA;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACKO,IAAM,UAAyB,OAAO,IAAI,eAAe;AAUzD,IAAM,YAA2B,OAAO,IAAI,iBAAiB;AAE7D,IAAM,cAA6B,OAAO,IAAI,aAAa;;;ACf3D,IAAM,SACZ,QAAQ,IAAI,aAAa,eACtB;AAAA;AAAA,EAEA,SAAS,QAAgB;AACxB,WAAO,mBAAmB,yFAAyF;AAAA,EACpH;AAAA,EACA,SAAS,OAAe;AACvB,WAAO,sJAAsJ;AAAA,EAC9J;AAAA,EACA;AAAA,EACA,SAAS,MAAW;AACnB,WACC,yHACA;AAAA,EAEF;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,SAAS,OAAe;AACvB,WAAO,mCAAmC;AAAA,EAC3C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,SAAS,OAAe;AACvB,WAAO,oCAAoC;AAAA,EAC5C;AAAA;AAAA;AAGA,IACA,CAAC;AAEE,SAAS,IAAI,UAAkB,MAAoB;AACzD,MAAI,QAAQ,IAAI,aAAa,cAAc;AAC1C,UAAM,IAAI,OAAO,KAAK;AACtB,UAAM,MAAM,WAAW,CAAC,IAAI,EAAE,MAAM,MAAM,IAAW,IAAI;AACzD,UAAM,IAAI,MAAM,WAAW,KAAK;AAAA,EACjC;AACA,QAAM,IAAI;AAAA,IACT,8BAA8B;AAAA,EAC/B;AACD;;;ACnCA,IAAM,IAAI;AAEH,IAAM,iBAAiB,EAAE;AAEzB,IAAM,cAAc;AACpB,IAAM,YAAY;AAElB,IAAM,eAAe;AACrB,IAAM,aAAa;AACnB,IAAM,WAAW;AACjB,IAAM,QAAQ;AAId,IAAI,UAAU,CAAC,UAAwB,CAAC,CAAC,SAAS,CAAC,CAAC,MAAM,WAAW;AAIrE,SAAS,YAAY,OAAqB;AAChD,MAAI,CAAC;AAAO,WAAO;AACnB,SACC,cAAc,KAAK,KACnB,QAAQ,KAAK,KACb,CAAC,CAAC,MAAM,SAAS,KACjB,CAAC,CAAC,MAAM,WAAW,IAAI,SAAS,KAChC,MAAM,KAAK,KACX,MAAM,KAAK;AAEb;AAEA,IAAM,mBAAmB,EAAE,SAAS,EAAE,WAAW,EAAE,SAAS;AAC5D,IAAM,oBAAoB,oBAAI,QAAQ;AAE/B,SAAS,cAAc,OAAqB;AAClD,MAAI,CAAC,SAAS,CAAC,YAAY,KAAK;AAAG,WAAO;AAC1C,QAAM,QAAQ,eAAe,KAAK;AAClC,MAAI,UAAU,QAAQ,UAAU,EAAE,SAAS;AAAG,WAAO;AAErD,QAAM,OAAO,EAAE,eAAe,KAAK,OAAO,WAAW,KAAK,MAAM,WAAW;AAC3E,MAAI,SAAS;AAAQ,WAAO;AAE5B,MAAI,CAAC,WAAW,IAAI;AAAG,WAAO;AAE9B,MAAI,aAAa,kBAAkB,IAAI,IAAI;AAC3C,MAAI,eAAe,QAAW;AAC7B,iBAAa,SAAS,SAAS,KAAK,IAAI;AACxC,sBAAkB,IAAI,MAAM,UAAU;AAAA,EACvC;AAEA,SAAO,eAAe;AACvB;AAKO,SAAS,SAAS,OAA0B;AAClD,MAAI,CAAC,QAAQ,KAAK;AAAG,QAAI,IAAI,KAAK;AAClC,SAAO,MAAM,WAAW,EAAE;AAC3B;AAgBO,SAAS,KAAK,KAAU,MAAW,SAAkB,MAAM;AACjE,MAAI,YAAY,GAAG,sBAAuB;AAGzC,UAAM,OAAO,SAAS,QAAQ,QAAQ,GAAG,IAAI,EAAE,KAAK,GAAG;AACvD,SAAK,QAAQ,SAAO;AACnB,WAAK,KAAK,IAAI,GAAG,GAAG,GAAG;AAAA,IACxB,CAAC;AAAA,EACF,OAAO;AACN,QAAI,QAAQ,CAAC,OAAY,UAAe,KAAK,OAAO,OAAO,GAAG,CAAC;AAAA,EAChE;AACD;AAGO,SAAS,YAAY,OAAsB;AACjD,QAAM,QAAgC,MAAM,WAAW;AACvD,SAAO,QACJ,MAAM,QACN,QAAQ,KAAK,oBAEb,MAAM,KAAK,kBAEX,MAAM,KAAK;AAGf;AAGO,IAAI,MAAM,CAChB,OACA,MACA,OAAO,YAAY,KAAK,MAExB,uBACG,MAAM,IAAI,IAAI,IACd,EAAE,SAAS,EAAE,eAAe,KAAK,OAAO,IAAI;AAGzC,IAAI,MAAM,CAChB,OACA,MACA,OAAO,YAAY,KAAK;AAAA;AAAA,EAGxB,uBAAwB,MAAM,IAAI,IAAI,IAAI,MAAM,IAAI;AAAA;AAG9C,IAAI,MAAM,CAChB,OACA,gBACA,OACA,OAAO,YAAY,KAAK,MACpB;AACJ,MAAI;AAAuB,UAAM,IAAI,gBAAgB,KAAK;AAAA,WACjD,sBAAuB;AAC/B,UAAM,IAAI,KAAK;AAAA,EAChB;AAAO,UAAM,cAAc,IAAI;AAChC;AAGO,SAAS,GAAG,GAAQ,GAAiB;AAE3C,MAAI,MAAM,GAAG;AACZ,WAAO,MAAM,KAAK,IAAI,MAAM,IAAI;AAAA,EACjC,OAAO;AACN,WAAO,MAAM,KAAK,MAAM;AAAA,EACzB;AACD;AAEO,IAAI,UAAU,MAAM;AAGpB,IAAI,QAAQ,CAAC,WAAkC,kBAAkB;AAGjE,IAAI,QAAQ,CAAC,WAAkC,kBAAkB;AAEjE,IAAI,cAAc,CAAC,WAAgB,OAAO,WAAW;AAErD,IAAI,aAAa,CAAC,WACxB,OAAO,WAAW;AAEZ,IAAI,YAAY,CAAC,WACvB,OAAO,WAAW;AAEZ,SAAS,aAAa,OAAkD;AAC9E,QAAM,IAAI,CAAC;AACX,SAAO,OAAO,UAAU,CAAC,KAAK,OAAO,CAAC,MAAM;AAC7C;AAEO,IAAI,gBAAgB,CAAgB,UAAgC;AAC1E,MAAI,CAAC,YAAY,KAAK;AAAG,WAAO;AAChC,SAAQ,QAAiC,WAAW;AACrD;AAGO,IAAI,SAAS,CAAC,UAA2B,MAAM,SAAS,MAAM;AAE9D,IAAI,WAAW,CAAmB,UAAgB;AACxD,QAAM,aAAa,cAAc,KAAK;AACtC,SAAO,aAAa,WAAW,SAAS,WAAW,QAAQ;AAC5D;AAEO,IAAI,gBAAgB,CAAC,UAC3B,MAAM,YAAY,MAAM,QAAQ,MAAM;AAGhC,SAAS,YAAY,MAAW,QAAoB;AAC1D,MAAI,MAAM,IAAI,GAAG;AAChB,WAAO,IAAI,IAAI,IAAI;AAAA,EACpB;AACA,MAAI,MAAM,IAAI,GAAG;AAChB,WAAO,IAAI,IAAI,IAAI;AAAA,EACpB;AACA,MAAI,QAAQ,IAAI;AAAG,WAAO,MAAM,SAAS,EAAE,MAAM,KAAK,IAAI;AAE1D,QAAM,UAAU,cAAc,IAAI;AAElC,MAAI,WAAW,QAAS,WAAW,gBAAgB,CAAC,SAAU;AAE7D,UAAM,cAAc,EAAE,0BAA0B,IAAI;AACpD,WAAO,YAAY,WAAkB;AACrC,QAAI,OAAO,QAAQ,QAAQ,WAAW;AACtC,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACrC,YAAM,MAAW,KAAK,CAAC;AACvB,YAAM,OAAO,YAAY,GAAG;AAC5B,UAAI,KAAK,QAAQ,MAAM,OAAO;AAC7B,aAAK,QAAQ,IAAI;AACjB,aAAK,YAAY,IAAI;AAAA,MACtB;AAIA,UAAI,KAAK,OAAO,KAAK;AACpB,oBAAY,GAAG,IAAI;AAAA,UAClB,CAAC,YAAY,GAAG;AAAA,UAChB,CAAC,QAAQ,GAAG;AAAA;AAAA,UACZ,CAAC,UAAU,GAAG,KAAK,UAAU;AAAA,UAC7B,CAAC,KAAK,GAAG,KAAK,GAAG;AAAA,QAClB;AAAA,IACF;AACA,WAAO,EAAE,OAAO,eAAe,IAAI,GAAG,WAAW;AAAA,EAClD,OAAO;AAEN,UAAM,QAAQ,eAAe,IAAI;AACjC,QAAI,UAAU,QAAQ,SAAS;AAC9B,aAAO,EAAC,GAAG,KAAI;AAAA,IAChB;AACA,UAAM,MAAM,EAAE,OAAO,KAAK;AAC1B,WAAO,EAAE,OAAO,KAAK,IAAI;AAAA,EAC1B;AACD;AAUO,SAAS,OAAU,KAAU,OAAgB,OAAU;AAC7D,MAAI,SAAS,GAAG,KAAK,QAAQ,GAAG,KAAK,CAAC,YAAY,GAAG;AAAG,WAAO;AAC/D,MAAI,YAAY,GAAG,IAAI,GAAoB;AAC1C,MAAE,iBAAiB,KAAK;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,OAAO;AAAA,MACP,QAAQ;AAAA,IACT,CAAC;AAAA,EACF;AACA,IAAE,OAAO,GAAG;AACZ,MAAI;AAGH;AAAA,MACC;AAAA,MACA,CAAC,MAAM,UAAU;AAChB,eAAO,OAAO,IAAI;AAAA,MACnB;AAAA,MACA;AAAA,IACD;AACD,SAAO;AACR;AAEA,SAAS,8BAA8B;AACtC,MAAI,CAAC;AACN;AAEA,IAAM,2BAA2B;AAAA,EAChC,CAAC,KAAK,GAAG;AACV;AAEO,SAAS,SAAS,KAAmB;AAE3C,MAAI,QAAQ,QAAQ,CAAC,YAAY,GAAG;AAAG,WAAO;AAC9C,SAAO,EAAE,SAAS,GAAG;AACtB;;;AChRO,IAAM,eAAe;AACrB,IAAM,gBAAgB;AACtB,IAAM,qBAAqB;AA8BlC,IAAM,UAIF,CAAC;AAIE,SAAS,UACf,WACiC;AACjC,QAAM,SAAS,QAAQ,SAAS;AAChC,MAAI,CAAC,QAAQ;AACZ,QAAI,GAAG,SAAS;AAAA,EACjB;AAEA,SAAO;AACR;AAEO,IAAI,iBAAiB,CAA0B,cACrD,CAAC,CAAC,QAAQ,SAAS;AAMb,SAAS,WACf,WACA,gBACO;AACP,MAAI,CAAC,QAAQ,SAAS;AAAG,YAAQ,SAAS,IAAI;AAC/C;;;ACxCA,IAAI;AAEG,IAAI,kBAAkB,MAAM;AAEnC,IAAI,cAAc,CACjB,SACA,YACiB;AAAA,EACjB,SAAS,CAAC;AAAA,EACV;AAAA,EACA;AAAA;AAAA;AAAA,EAGA,gBAAgB;AAAA,EAChB,oBAAoB;AAAA,EACpB,aAAa,oBAAI,IAAI;AAAA,EACrB,sBAAsB,oBAAI,IAAI;AAAA,EAC9B,eAAe,eAAe,YAAY,IACvC,UAAU,YAAY,IACtB;AAAA,EACH,qBAAqB,eAAe,kBAAkB,IACnD,UAAU,kBAAkB,IAC5B;AACJ;AAEO,SAAS,kBACf,OACA,eACC;AACD,MAAI,eAAe;AAClB,UAAM,eAAe,UAAU,aAAa;AAC5C,UAAM,WAAW,CAAC;AAClB,UAAM,kBAAkB,CAAC;AACzB,UAAM,iBAAiB;AAAA,EACxB;AACD;AAEO,SAAS,YAAY,OAAmB;AAC9C,aAAW,KAAK;AAChB,QAAM,QAAQ,QAAQ,WAAW;AAEjC,QAAM,UAAU;AACjB;AAEO,SAAS,WAAW,OAAmB;AAC7C,MAAI,UAAU,cAAc;AAC3B,mBAAe,MAAM;AAAA,EACtB;AACD;AAEO,IAAI,aAAa,CAACC,WACvB,eAAe,YAAY,cAAcA,MAAK;AAEhD,SAAS,YAAY,OAAgB;AACpC,QAAM,QAAoB,MAAM,WAAW;AAC3C,MAAI,MAAM,4BAA6B,MAAM;AAC5C,UAAM,QAAQ;AAAA;AACV,UAAM,WAAW;AACvB;;;ACpEO,SAAS,cAAc,QAAa,OAAmB;AAC7D,QAAM,qBAAqB,MAAM,QAAQ;AACzC,QAAM,YAAY,MAAM,QAAS,CAAC;AAClC,QAAM,aAAa,WAAW,UAAa,WAAW;AAEtD,MAAI,YAAY;AACf,QAAI,UAAU,WAAW,EAAE,WAAW;AACrC,kBAAY,KAAK;AACjB,UAAI,CAAC;AAAA,IACN;AACA,QAAI,YAAY,MAAM,GAAG;AAExB,eAAS,SAAS,OAAO,MAAM;AAAA,IAChC;AACA,UAAM,EAAC,aAAY,IAAI;AACvB,QAAI,cAAc;AACjB,mBAAa;AAAA,QACZ,UAAU,WAAW,EAAE;AAAA,QACvB;AAAA,QACA;AAAA,MACD;AAAA,IACD;AAAA,EACD,OAAO;AAEN,aAAS,SAAS,OAAO,SAAS;AAAA,EACnC;AAEA,cAAY,OAAO,QAAQ,IAAI;AAE/B,cAAY,KAAK;AACjB,MAAI,MAAM,UAAU;AACnB,UAAM,eAAgB,MAAM,UAAU,MAAM,eAAgB;AAAA,EAC7D;AACA,SAAO,WAAW,UAAU,SAAS;AACtC;AAEA,SAAS,SAAS,WAAuB,OAAY;AAEpD,MAAI,SAAS,KAAK;AAAG,WAAO;AAE5B,QAAM,QAAoB,MAAM,WAAW;AAC3C,MAAI,CAAC,OAAO;AACX,UAAM,aAAa,YAAY,OAAO,UAAU,aAAa,SAAS;AACtE,WAAO;AAAA,EACR;AAGA,MAAI,CAAC,YAAY,OAAO,SAAS,GAAG;AACnC,WAAO;AAAA,EACR;AAGA,MAAI,CAAC,MAAM,WAAW;AACrB,WAAO,MAAM;AAAA,EACd;AAEA,MAAI,CAAC,MAAM,YAAY;AAEtB,UAAM,EAAC,WAAU,IAAI;AACrB,QAAI,YAAY;AACf,aAAO,WAAW,SAAS,GAAG;AAC7B,cAAM,WAAW,WAAW,IAAI;AAChC,iBAAS,SAAS;AAAA,MACnB;AAAA,IACD;AAEA,+BAA2B,OAAO,SAAS;AAAA,EAC5C;AAGA,SAAO,MAAM;AACd;AAEA,SAAS,YAAY,OAAmB,OAAY,OAAO,OAAO;AAEjE,MAAI,CAAC,MAAM,WAAW,MAAM,OAAO,eAAe,MAAM,gBAAgB;AACvE,WAAO,OAAO,IAAI;AAAA,EACnB;AACD;AAEA,SAAS,mBAAmB,OAAmB;AAC9C,QAAM,aAAa;AACnB,QAAM,OAAO;AACd;AAEA,IAAI,cAAc,CAAC,OAAmB,cACrC,MAAM,WAAW;AAGlB,IAAM,yBAAuD,CAAC;AAIvD,SAAS,oBACf,QACA,YACA,gBACA,aACO;AACP,QAAM,aAAa,OAAO,MAAM;AAChC,QAAM,aAAa,OAAO;AAG1B,MAAI,gBAAgB,QAAW;AAC9B,UAAM,eAAe,IAAI,YAAY,aAAa,UAAU;AAC5D,QAAI,iBAAiB,YAAY;AAEhC,UAAI,YAAY,aAAa,gBAAgB,UAAU;AACvD;AAAA,IACD;AAAA,EACD;AAMA,MAAI,CAAC,OAAO,iBAAiB;AAC5B,UAAM,iBAAkB,OAAO,kBAAkB,oBAAI,IAAI;AAGzD,SAAK,YAAY,CAAC,KAAK,UAAU;AAChC,UAAI,QAAQ,KAAK,GAAG;AACnB,cAAM,OAAO,eAAe,IAAI,KAAK,KAAK,CAAC;AAC3C,aAAK,KAAK,GAAG;AACb,uBAAe,IAAI,OAAO,IAAI;AAAA,MAC/B;AAAA,IACD,CAAC;AAAA,EACF;AAGA,QAAM,YACL,OAAO,gBAAgB,IAAI,UAAU,KAAK;AAG3C,aAAW,YAAY,WAAW;AACjC,QAAI,YAAY,UAAU,gBAAgB,UAAU;AAAA,EACrD;AACD;AAKO,SAAS,kCACf,QACA,OACA,KACC;AACD,SAAO,WAAW,KAAK,SAAS,aAAa,WAAW;AACvD,UAAM,QAAoB;AAG1B,QAAI,CAAC,SAAS,CAAC,YAAY,OAAO,SAAS,GAAG;AAC7C;AAAA,IACD;AAGA,cAAU,eAAe,eAAe,KAAK;AAE7C,UAAM,iBAAiB,cAAc,KAAK;AAG1C,wBAAoB,QAAQ,MAAM,UAAU,OAAO,gBAAgB,GAAG;AAEtE,+BAA2B,OAAO,SAAS;AAAA,EAC5C,CAAC;AACF;AAEA,SAAS,2BAA2B,OAAmB,WAAuB;AAC7E,QAAM,iBACL,MAAM,aACN,CAAC,MAAM,eACN,MAAM,yBACL,MAAM,2BACL,MAA0B,0BAC3B,MAAM,WAAW,QAAQ,KAAK;AAEjC,MAAI,gBAAgB;AACnB,UAAM,EAAC,aAAY,IAAI;AACvB,QAAI,cAAc;AACjB,YAAM,WAAW,aAAc,QAAQ,KAAK;AAE5C,UAAI,UAAU;AACb,qBAAc,iBAAiB,OAAO,UAAU,SAAS;AAAA,MAC1D;AAAA,IACD;AAEA,uBAAmB,KAAK;AAAA,EACzB;AACD;AAEO,SAAS,qBACf,QACA,KACA,OACC;AACD,QAAM,EAAC,OAAM,IAAI;AAEjB,MAAI,QAAQ,KAAK,GAAG;AACnB,UAAM,QAAoB,MAAM,WAAW;AAC3C,QAAI,YAAY,OAAO,MAAM,GAAG;AAG/B,YAAM,WAAW,KAAK,SAAS,wBAAwB;AAEtD,oBAAY,MAAM;AAElB,cAAM,iBAAiB,cAAc,KAAK;AAE1C,4BAAoB,QAAQ,OAAO,gBAAgB,GAAG;AAAA,MACvD,CAAC;AAAA,IACF;AAAA,EACD,WAAW,YAAY,KAAK,GAAG;AAE9B,WAAO,WAAW,KAAK,SAAS,qBAAqB;AACpD,YAAM,aAAa,OAAO,MAAM;AAGhC,UAAI,OAAO,uBAAwB;AAClC,YAAI,WAAW,IAAI,KAAK,GAAG;AAE1B,sBAAY,OAAO,OAAO,aAAa,MAAM;AAAA,QAC9C;AAAA,MACD,OAAO;AAEN,YAAI,IAAI,YAAY,KAAK,OAAO,KAAK,MAAM,OAAO;AACjD,cACC,OAAO,QAAQ,SAAS,MACtB,OAAyC,UAAW,IAAI,GAAG,KAC5D,WAAW,QACZ,OAAO,OACN;AAGD;AAAA,cACC,IAAI,OAAO,OAAO,KAAK,OAAO,KAAK;AAAA,cACnC,OAAO;AAAA,cACP;AAAA,YACD;AAAA,UACD;AAAA,QACD;AAAA,MACD;AAAA,IACD,CAAC;AAAA,EACF;AACD;AAEO,SAAS,YACf,QACA,YACA,WACC;AACD,MAAI,CAAC,UAAU,OAAO,eAAe,UAAU,qBAAqB,GAAG;AAMtE,WAAO;AAAA,EACR;AAGA,MACC,QAAQ,MAAM,KACd,WAAW,IAAI,MAAM,KACrB,CAAC,YAAY,MAAM,KACnB,SAAS,MAAM,GACd;AACD,WAAO;AAAA,EACR;AAEA,aAAW,IAAI,MAAM;AAGrB,OAAK,QAAQ,CAAC,KAAK,UAAU;AAC5B,QAAI,QAAQ,KAAK,GAAG;AACnB,YAAM,QAAoB,MAAM,WAAW;AAC3C,UAAI,YAAY,OAAO,SAAS,GAAG;AAGlC,cAAM,eAAe,cAAc,KAAK;AAExC,YAAI,QAAQ,KAAK,cAAc,OAAO,KAAK;AAE3C,2BAAmB,KAAK;AAAA,MACzB;AAAA,IACD,WAAW,YAAY,KAAK,GAAG;AAE9B,kBAAY,OAAO,YAAY,SAAS;AAAA,IACzC;AAAA,EACD,CAAC;AAED,SAAO;AACR;;;ACtQO,SAAS,iBACf,MACA,QACuC;AACvC,QAAM,cAAc,QAAQ,IAAI;AAChC,QAAM,QAAoB;AAAA,IACzB,OAAO;AAAA;AAAA,IAEP,QAAQ,SAAS,OAAO,SAAS,gBAAgB;AAAA;AAAA,IAEjD,WAAW;AAAA;AAAA,IAEX,YAAY;AAAA;AAAA;AAAA,IAGZ,WAAW;AAAA;AAAA,IAEX,SAAS;AAAA;AAAA,IAET,OAAO;AAAA;AAAA,IAEP,QAAQ;AAAA;AAAA;AAAA,IAER,OAAO;AAAA;AAAA,IAEP,SAAS;AAAA,IACT,WAAW;AAAA;AAAA,IAEX,YAAY;AAAA,EACb;AAQA,MAAI,SAAY;AAChB,MAAI,QAA2C;AAC/C,MAAI,aAAa;AAChB,aAAS,CAAC,KAAK;AACf,YAAQ;AAAA,EACT;AAEA,QAAM,EAAC,QAAQ,MAAK,IAAI,MAAM,UAAU,QAAQ,KAAK;AACrD,QAAM,SAAS;AACf,QAAM,UAAU;AAChB,SAAO,CAAC,OAAc,KAAK;AAC5B;AAKO,IAAM,cAAwC;AAAA,EACpD,IAAI,OAAO,MAAM;AAChB,QAAI,SAAS;AAAa,aAAO;AAEjC,QAAI,cAAc,MAAM,OAAO;AAC/B,UAAM,wBACL,MAAM,2BAA4B,OAAO,SAAS;AAGnD,QAAI,uBAAuB;AAC1B,UAAI,aAAa,uBAAuB,IAAI,GAAG;AAC9C,eAAO,YAAY,wBAAwB,OAAO,IAAI;AAAA,MACvD;AAAA,IACD;AAEA,UAAM,SAAS,OAAO,KAAK;AAC3B,QAAI,CAAC,IAAI,QAAQ,MAAM,MAAM,KAAK,GAAG;AAEpC,aAAO,kBAAkB,OAAO,QAAQ,IAAI;AAAA,IAC7C;AACA,UAAM,QAAQ,OAAO,IAAI;AACzB,QAAI,MAAM,cAAc,CAAC,YAAY,KAAK,GAAG;AAC5C,aAAO;AAAA,IACR;AAIA,QACC,yBACC,MAA0B,mBAC3B,aAAa;AAAA,MACX,MAA0B;AAAA,IAC5B,KACA,aAAa,IAAI,GAChB;AAED,aAAO;AAAA,IACR;AAGA,QAAI,UAAU,KAAK,MAAM,OAAO,IAAI,GAAG;AACtC,kBAAY,KAAK;AAEjB,YAAM,WAAW,MAAM,0BAA2B,CAAE,OAAkB;AACtE,YAAM,aAAa,YAAY,MAAM,QAAQ,OAAO,OAAO,QAAQ;AAEnE,aAAQ,MAAM,MAAO,QAAQ,IAAI;AAAA,IAClC;AACA,WAAO;AAAA,EACR;AAAA,EACA,IAAI,OAAO,MAAM;AAChB,WAAO,QAAQ,OAAO,KAAK;AAAA,EAC5B;AAAA,EACA,QAAQ,OAAO;AACd,WAAO,QAAQ,QAAQ,OAAO,KAAK,CAAC;AAAA,EACrC;AAAA,EACA,IACC,OACA,MACA,OACC;AACD,UAAM,OAAO,uBAAuB,OAAO,KAAK,GAAG,IAAI;AACvD,QAAI,MAAM,KAAK;AAGd,WAAK,IAAI,KAAK,MAAM,QAAQ,KAAK;AACjC,aAAO;AAAA,IACR;AACA,QAAI,CAAC,MAAM,WAAW;AAGrB,YAAMC,WAAU,KAAK,OAAO,KAAK,GAAG,IAAI;AAExC,YAAM,eAAiCA,WAAU,WAAW;AAC5D,UAAI,gBAAgB,aAAa,UAAU,OAAO;AACjD,cAAM,MAAO,IAAI,IAAI;AACrB,cAAM,UAAW,IAAI,MAAM,KAAK;AAChC,eAAO;AAAA,MACR;AACA,UACC,GAAG,OAAOA,QAAO,MAChB,UAAU,UAAa,IAAI,MAAM,OAAO,MAAM,MAAM,KAAK;AAE1D,eAAO;AACR,kBAAY,KAAK;AACjB,kBAAY,KAAK;AAAA,IAClB;AAEA,QACE,MAAM,MAAO,IAAI,MAAM;AAAA,KAEtB,UAAU,UAAa,QAAQ,MAAM;AAAA,IAEtC,OAAO,MAAM,KAAK,KAAK,OAAO,MAAM,MAAM,MAAO,IAAI,CAAC;AAEvD,aAAO;AAGR,UAAM,MAAO,IAAI,IAAI;AACrB,UAAM,UAAW,IAAI,MAAM,IAAI;AAE/B,yBAAqB,OAAO,MAAM,KAAK;AACvC,WAAO;AAAA,EACR;AAAA,EACA,eAAe,OAAO,MAAc;AACnC,gBAAY,KAAK;AAEjB,QAAI,KAAK,MAAM,OAAO,IAAI,MAAM,UAAa,QAAQ,MAAM,OAAO;AACjE,YAAM,UAAW,IAAI,MAAM,KAAK;AAChC,kBAAY,KAAK;AAAA,IAClB,OAAO;AAEN,YAAM,UAAW,OAAO,IAAI;AAAA,IAC7B;AACA,QAAI,MAAM,OAAO;AAChB,aAAO,MAAM,MAAM,IAAI;AAAA,IACxB;AACA,WAAO;AAAA,EACR;AAAA;AAAA;AAAA,EAGA,yBAAyB,OAAO,MAAM;AACrC,UAAM,QAAQ,OAAO,KAAK;AAC1B,UAAM,OAAO,QAAQ,yBAAyB,OAAO,IAAI;AACzD,QAAI,CAAC;AAAM,aAAO;AAClB,WAAO;AAAA,MACN,CAAC,QAAQ,GAAG;AAAA,MACZ,CAAC,YAAY,GAAG,MAAM,2BAA4B,SAAS;AAAA,MAC3D,CAAC,UAAU,GAAG,KAAK,UAAU;AAAA,MAC7B,CAAC,KAAK,GAAG,MAAM,IAAI;AAAA,IACpB;AAAA,EACD;AAAA,EACA,iBAAiB;AAChB,QAAI,EAAE;AAAA,EACP;AAAA,EACA,eAAe,OAAO;AACrB,WAAO,eAAe,MAAM,KAAK;AAAA,EAClC;AAAA,EACA,iBAAiB;AAChB,QAAI,EAAE;AAAA,EACP;AACD;AAMA,IAAM,aAA8C,CAAC;AAGrD,SAAS,OAAO,aAAa;AAC5B,MAAI,KAAK,YAAY,GAA+B;AAEpD,aAAW,GAAG,IAAI,WAAW;AAC5B,UAAM,OAAO;AACb,SAAK,CAAC,IAAI,KAAK,CAAC,EAAE,CAAC;AACnB,WAAO,GAAG,MAAM,MAAM,IAAI;AAAA,EAC3B;AACD;AACA,WAAW,iBAAiB,SAAS,OAAO,MAAM;AACjD,MAAI,QAAQ,IAAI,aAAa,gBAAgB,MAAM,SAAS,IAAW,CAAC;AACvE,QAAI,EAAE;AAEP,SAAO,WAAW,IAAK,KAAK,MAAM,OAAO,MAAM,MAAS;AACzD;AACA,WAAW,MAAM,SAAS,OAAO,MAAM,OAAO;AAC7C,MACC,QAAQ,IAAI,aAAa,gBACzB,SAAS,YACT,MAAM,SAAS,IAAW,CAAC;AAE3B,QAAI,EAAE;AACP,SAAO,YAAY,IAAK,KAAK,MAAM,MAAM,CAAC,GAAG,MAAM,OAAO,MAAM,CAAC,CAAC;AACnE;AAGA,SAAS,KAAK,OAAgB,MAAmB;AAChD,QAAM,QAAQ,MAAM,WAAW;AAC/B,QAAM,SAAS,QAAQ,OAAO,KAAK,IAAI;AACvC,SAAO,OAAO,IAAI;AACnB;AAEA,SAAS,kBAAkB,OAAmB,QAAa,MAAmB;AAC7E,QAAM,OAAO,uBAAuB,QAAQ,IAAI;AAChD,SAAO,OACJ,SAAS,OACR,KAAK,KAAK;AAAA;AAAA;AAAA,IAGV,KAAK,KAAK,KAAK,MAAM,MAAM;AAAA,MAC5B;AACJ;AAEA,SAAS,uBACR,QACA,MACiC;AAEjC,MAAI,EAAE,QAAQ;AAAS,WAAO;AAC9B,MAAI,QAAQ,eAAe,MAAM;AACjC,SAAO,OAAO;AACb,UAAM,OAAO,OAAO,yBAAyB,OAAO,IAAI;AACxD,QAAI;AAAM,aAAO;AACjB,YAAQ,eAAe,KAAK;AAAA,EAC7B;AACA,SAAO;AACR;AAEO,SAAS,YAAY,OAAmB;AAC9C,MAAI,CAAC,MAAM,WAAW;AACrB,UAAM,YAAY;AAClB,QAAI,MAAM,SAAS;AAClB,kBAAY,MAAM,OAAO;AAAA,IAC1B;AAAA,EACD;AACD;AAEO,SAAS,YAAY,OAAmB;AAC9C,MAAI,CAAC,MAAM,OAAO;AAGjB,UAAM,YAAY,oBAAI,IAAI;AAC1B,UAAM,QAAQ;AAAA,MACb,MAAM;AAAA,MACN,MAAM,OAAO,OAAO;AAAA,IACrB;AAAA,EACD;AACD;;;ACjSO,IAAMC,SAAN,MAAoC;AAAA,EAK1C,YAAY,QAIT;AARH,uBAAuB;AACvB,iCAAoC;AACpC,+BAA+B;AAiC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAoB,CAAC,MAAW,QAAc,kBAAwB;AAErE,UAAI,WAAW,IAAI,KAAK,CAAC,WAAW,MAAM,GAAG;AAC5C,cAAM,cAAc;AACpB,iBAAS;AAET,cAAM,OAAO;AACb,eAAO,SAAS,eAEfC,QAAO,gBACJ,MACF;AACD,iBAAO,KAAK,QAAQA,OAAM,CAAC,UAAmB,OAAO,KAAK,MAAM,OAAO,GAAG,IAAI,CAAC;AAAA,QAChF;AAAA,MACD;AAEA,UAAI,CAAC,WAAW,MAAM;AAAG,YAAI,CAAC;AAC9B,UAAI,kBAAkB,UAAa,CAAC,WAAW,aAAa;AAAG,YAAI,CAAC;AAEpE,UAAI;AAGJ,UAAI,YAAY,IAAI,GAAG;AACtB,cAAM,QAAQ,WAAW,IAAI;AAC7B,cAAM,QAAQ,YAAY,OAAO,MAAM,MAAS;AAChD,YAAI,WAAW;AACf,YAAI;AACH,mBAAS,OAAO,KAAK;AACrB,qBAAW;AAAA,QACZ,UAAE;AAED,cAAI;AAAU,wBAAY,KAAK;AAAA;AAC1B,uBAAW,KAAK;AAAA,QACtB;AACA,0BAAkB,OAAO,aAAa;AACtC,eAAO,cAAc,QAAQ,KAAK;AAAA,MACnC,WAAW,CAAC,QAAQ,CAAC,YAAY,IAAI,GAAG;AACvC,iBAAS,OAAO,IAAI;AACpB,YAAI,WAAW;AAAW,mBAAS;AACnC,YAAI,WAAW;AAAS,mBAAS;AACjC,YAAI,KAAK;AAAa,iBAAO,QAAQ,IAAI;AACzC,YAAI,eAAe;AAClB,gBAAM,IAAa,CAAC;AACpB,gBAAM,KAAc,CAAC;AACrB,oBAAU,aAAa,EAAE,4BAA4B,MAAM,QAAQ;AAAA,YAClE,UAAU;AAAA,YACV,iBAAiB;AAAA,UAClB,CAAe;AACf,wBAAc,GAAG,EAAE;AAAA,QACpB;AACA,eAAO;AAAA,MACR;AAAO,YAAI,GAAG,IAAI;AAAA,IACnB;AAEA,8BAA0C,CAAC,MAAW,WAAsB;AAE3E,UAAI,WAAW,IAAI,GAAG;AACrB,eAAO,CAAC,UAAe,SACtB,KAAK,mBAAmB,OAAO,CAAC,UAAe,KAAK,OAAO,GAAG,IAAI,CAAC;AAAA,MACrE;AAEA,UAAI,SAAkB;AACtB,YAAM,SAAS,KAAK,QAAQ,MAAM,QAAQ,CAAC,GAAY,OAAgB;AACtE,kBAAU;AACV,yBAAiB;AAAA,MAClB,CAAC;AACD,aAAO,CAAC,QAAQ,SAAU,cAAe;AAAA,IAC1C;AA7FC,QAAI,UAAU,QAAQ,UAAU;AAAG,WAAK,cAAc,OAAQ,UAAU;AACxE,QAAI,UAAU,QAAQ,oBAAoB;AACzC,WAAK,wBAAwB,OAAQ,oBAAoB;AAC1D,QAAI,UAAU,QAAQ,kBAAkB;AACvC,WAAK,sBAAsB,OAAQ,kBAAkB;AAAA,EACvD;AAAA,EA0FA,YAAiC,MAAmB;AACnD,QAAI,CAAC,YAAY,IAAI;AAAG,UAAI,CAAC;AAC7B,QAAI,QAAQ,IAAI;AAAG,aAAO,QAAQ,IAAI;AACtC,UAAM,QAAQ,WAAW,IAAI;AAC7B,UAAM,QAAQ,YAAY,OAAO,MAAM,MAAS;AAChD,UAAM,WAAW,EAAE,YAAY;AAC/B,eAAW,KAAK;AAChB,WAAO;AAAA,EACR;AAAA,EAEA,YACC,OACA,eACuC;AACvC,UAAM,QAAoB,SAAU,MAAc,WAAW;AAC7D,QAAI,CAAC,SAAS,CAAC,MAAM;AAAW,UAAI,CAAC;AACrC,UAAM,EAAC,QAAQ,MAAK,IAAI;AACxB,sBAAkB,OAAO,aAAa;AACtC,WAAO,cAAc,QAAW,KAAK;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc,OAAgB;AAC7B,SAAK,cAAc;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,wBAAwB,OAAmB;AAC1C,SAAK,wBAAwB;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,sBAAsB,OAAgB;AACrC,SAAK,sBAAsB;AAAA,EAC5B;AAAA,EAEA,2BAAoC;AACnC,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,aAAkC,MAAS,SAA8B;AAGxE,QAAI;AACJ,SAAK,IAAI,QAAQ,SAAS,GAAG,KAAK,GAAG,KAAK;AACzC,YAAM,QAAQ,QAAQ,CAAC;AACvB,UAAI,MAAM,KAAK,WAAW,KAAK,MAAM,OAAO,WAAW;AACtD,eAAO,MAAM;AACb;AAAA,MACD;AAAA,IACD;AAGA,QAAI,IAAI,IAAI;AACX,gBAAU,QAAQ,MAAM,IAAI,CAAC;AAAA,IAC9B;AAEA,UAAM,mBAAmB,UAAU,aAAa,EAAE;AAClD,QAAI,QAAQ,IAAI,GAAG;AAElB,aAAO,iBAAiB,MAAM,OAAO;AAAA,IACtC;AAEA,WAAO,KAAK;AAAA,MAAQ;AAAA,MAAM,CAAC,UAC1B,iBAAiB,OAAO,OAAO;AAAA,IAChC;AAAA,EACD;AACD;AAEO,SAAS,YACf,WACA,OACA,QACA,KACyB;AAIzB,QAAM,CAAC,OAAO,KAAK,IAAI,MAAM,KAAK,IAC/B,UAAU,YAAY,EAAE,UAAU,OAAO,MAAM,IAC/C,MAAM,KAAK,IACX,UAAU,YAAY,EAAE,UAAU,OAAO,MAAM,IAC/C,iBAAiB,OAAO,MAAM;AAEjC,QAAM,QAAQ,QAAQ,UAAU,gBAAgB;AAChD,QAAM,QAAQ,KAAK,KAAK;AAIxB,QAAM,aAAa,QAAQ,cAAc,CAAC;AAC1C,QAAM,OAAO;AAEb,MAAI,UAAU,QAAQ,QAAW;AAChC,sCAAkC,QAAQ,OAAO,GAAG;AAAA,EACrD,OAAO;AAEN,UAAM,WAAW,KAAK,SAAS,iBAAiBC,YAAW;AAC1D,MAAAA,WAAU,eAAe,eAAe,KAAK;AAE7C,YAAM,EAAC,aAAY,IAAIA;AAEvB,UAAI,MAAM,aAAa,cAAc;AACpC,qBAAa,iBAAiB,OAAO,CAAC,GAAGA,UAAS;AAAA,MACnD;AAAA,IACD,CAAC;AAAA,EACF;AAEA,SAAO;AACR;;;AClQO,SAAS,QAAQ,OAAiB;AACxC,MAAI,CAAC,QAAQ,KAAK;AAAG,QAAI,IAAI,KAAK;AAClC,SAAO,YAAY,KAAK;AACzB;AAEA,SAAS,YAAY,OAAiB;AACrC,MAAI,CAAC,YAAY,KAAK,KAAK,SAAS,KAAK;AAAG,WAAO;AACnD,QAAM,QAAgC,MAAM,WAAW;AACvD,MAAI;AACJ,MAAI,SAAS;AACb,MAAI,OAAO;AACV,QAAI,CAAC,MAAM;AAAW,aAAO,MAAM;AAEnC,UAAM,aAAa;AACnB,WAAO,YAAY,OAAO,MAAM,OAAO,OAAO,qBAAqB;AACnE,aAAS,MAAM,OAAO,OAAO,yBAAyB;AAAA,EACvD,OAAO;AACN,WAAO,YAAY,OAAO,IAAI;AAAA,EAC/B;AAEA;AAAA,IACC;AAAA,IACA,CAAC,KAAK,eAAe;AACpB,UAAI,MAAM,KAAK,YAAY,UAAU,CAAC;AAAA,IACvC;AAAA,IACA;AAAA,EACD;AACA,MAAI,OAAO;AACV,UAAM,aAAa;AAAA,EACpB;AACA,SAAO;AACR;;;ACXO,SAAS,gBAAgB;AAC/B,QAAM,cAAc;AACpB,MAAI,QAAQ,IAAI,aAAa,cAAc;AAC1C,WAAO;AAAA,MACN;AAAA,MACA,SAAS,IAAY;AACpB,eAAO,kCAAkC;AAAA,MAC1C;AAAA,MACA,SAAS,MAAc;AACtB,eAAO,+CAA+C;AAAA,MACvD;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAEA,WAAS,QAAQ,OAAmB,OAAkB,CAAC,GAAqB;AAE3E,QAAI,MAAM,SAAS,QAAW;AAG7B,YAAM,aAAa,MAAM,QAAS,SAAS,MAAM,QAAS;AAC1D,YAAM,aAAa,cAAc,IAAI,YAAY,MAAM,IAAK,CAAC;AAC7D,YAAM,aAAa,IAAI,YAAY,MAAM,IAAK;AAE9C,UAAI,eAAe,QAAW;AAC7B,eAAO;AAAA,MACR;AAIA,UACC,eAAe,MAAM,UACrB,eAAe,MAAM,SACrB,eAAe,MAAM,OACpB;AACD,eAAO;AAAA,MACR;AACA,UAAI,cAAc,QAAQ,WAAW,UAAU,MAAM,OAAO;AAC3D,eAAO;AAAA,MACR;AAGA,YAAMC,SAAQ,MAAM,QAAS;AAC7B,UAAI;AAEJ,UAAIA,QAAO;AAEV,cAAM,YAAY,MAAM;AACxB,cAAM,MAAM,KAAK,UAAU,QAAQ,KAAK,CAAC,EAAE,QAAQ,MAAM,IAAI;AAAA,MAC9D,OAAO;AACN,cAAM,MAAM;AAAA,MACb;AAGA,UAAI,EAAGA,UAAS,WAAW,OAAO,OAAQ,IAAI,YAAY,GAAG,IAAI;AAChE,eAAO;AAAA,MACR;AAGA,WAAK,KAAK,GAAG;AAAA,IACd;AAGA,QAAI,MAAM,SAAS;AAClB,aAAO,QAAQ,MAAM,SAAS,IAAI;AAAA,IACnC;AAGA,SAAK,QAAQ;AAEb,QAAI;AAEH,kBAAY,MAAM,OAAO,IAAI;AAAA,IAC9B,SAAS,GAAP;AACD,aAAO;AAAA,IACR;AAEA,WAAO;AAAA,EACR;AAGA,WAAS,YAAY,MAAW,MAAsB;AACrD,QAAIC,WAAU;AACd,aAAS,IAAI,GAAG,IAAI,KAAK,SAAS,GAAG,KAAK;AACzC,YAAM,MAAM,KAAK,CAAC;AAClB,MAAAA,WAAU,IAAIA,UAAS,GAAG;AAC1B,UAAI,CAAC,YAAYA,QAAO,KAAKA,aAAY,MAAM;AAC9C,cAAM,IAAI,MAAM,2BAA2B,KAAK,KAAK,GAAG,IAAI;AAAA,MAC7D;AAAA,IACD;AACA,WAAOA;AAAA,EACR;AAEA,QAAM,UAAU;AAChB,QAAM,MAAM;AACZ,QAAM,SAAS;AAEf,WAAS,iBACR,OACA,UACA,OACO;AACP,QAAI,MAAM,OAAO,qBAAqB,IAAI,KAAK,GAAG;AACjD;AAAA,IACD;AAEA,UAAM,OAAO,qBAAqB,IAAI,KAAK;AAE3C,UAAM,EAAC,UAAU,gBAAe,IAAI;AAEpC,YAAQ,MAAM,OAAO;AAAA,MACpB;AAAA,MACA;AACC,eAAO;AAAA,UACN;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AAAA,MACD;AACC,eAAO;AAAA,UACN;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACD;AAAA,MACD;AACC,eAAO;AAAA,UACL;AAAA,UACD;AAAA,UACA;AAAA,UACA;AAAA,QACD;AAAA,IACF;AAAA,EACD;AAEA,WAAS,qBACR,OACA,UACA,SACA,gBACC;AACD,QAAI,EAAC,OAAO,UAAS,IAAI;AACzB,QAAI,QAAQ,MAAM;AAGlB,QAAI,MAAM,SAAS,MAAM,QAAQ;AAEhC;AAAC,OAAC,OAAO,KAAK,IAAI,CAAC,OAAO,KAAK;AAC9B,OAAC,SAAS,cAAc,IAAI,CAAC,gBAAgB,OAAO;AAAA,IACtD;AAEA,UAAM,gBAAgB,MAAM,0BAA0B;AAGtD,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,YAAM,aAAa,MAAM,CAAC;AAC1B,YAAM,WAAW,MAAM,CAAC;AAExB,YAAM,aAAa,iBAAiB,WAAW,IAAI,EAAE,SAAS,CAAC;AAC/D,UAAI,cAAc,eAAe,UAAU;AAC1C,cAAM,aAAa,aAAa,WAAW;AAC3C,YAAI,cAAc,WAAW,WAAW;AAEvC;AAAA,QACD;AACA,cAAM,OAAO,SAAS,OAAO,CAAC,CAAC,CAAC;AAChC,gBAAQ,KAAK;AAAA,UACZ,IAAI;AAAA,UACJ;AAAA;AAAA;AAAA,UAGA,OAAO,wBAAwB,UAAU;AAAA,QAC1C,CAAC;AACD,uBAAe,KAAK;AAAA,UACnB,IAAI;AAAA,UACJ;AAAA,UACA,OAAO,wBAAwB,QAAQ;AAAA,QACxC,CAAC;AAAA,MACF;AAAA,IACD;AAGA,aAAS,IAAI,MAAM,QAAQ,IAAI,MAAM,QAAQ,KAAK;AACjD,YAAM,OAAO,SAAS,OAAO,CAAC,CAAC,CAAC;AAChC,cAAQ,KAAK;AAAA,QACZ,IAAI;AAAA,QACJ;AAAA;AAAA;AAAA,QAGA,OAAO,wBAAwB,MAAM,CAAC,CAAC;AAAA,MACxC,CAAC;AAAA,IACF;AACA,aAAS,IAAI,MAAM,SAAS,GAAG,MAAM,UAAU,GAAG,EAAE,GAAG;AACtD,YAAM,OAAO,SAAS,OAAO,CAAC,CAAC,CAAC;AAChC,qBAAe,KAAK;AAAA,QACnB,IAAI;AAAA,QACJ;AAAA,MACD,CAAC;AAAA,IACF;AAAA,EACD;AAGA,WAAS,4BACR,OACA,UACA,SACA,gBACC;AACD,UAAM,EAAC,OAAO,OAAO,MAAK,IAAI;AAC9B,SAAK,MAAM,WAAY,CAAC,KAAK,kBAAkB;AAC9C,YAAM,YAAY,IAAI,OAAO,KAAK,KAAK;AACvC,YAAM,QAAQ,IAAI,OAAQ,KAAK,KAAK;AACpC,YAAM,KAAK,CAAC,gBAAgB,SAAS,IAAI,OAAO,GAAG,IAAI,UAAU;AACjE,UAAI,cAAc,SAAS,OAAO;AAAS;AAC3C,YAAM,OAAO,SAAS,OAAO,GAAU;AACvC,cAAQ;AAAA,QACP,OAAO,SACJ,EAAC,IAAI,KAAI,IACT,EAAC,IAAI,MAAM,OAAO,wBAAwB,KAAK,EAAC;AAAA,MACpD;AACA,qBAAe;AAAA,QACd,OAAO,MACJ,EAAC,IAAI,QAAQ,KAAI,IACjB,OAAO,SACP,EAAC,IAAI,KAAK,MAAM,OAAO,wBAAwB,SAAS,EAAC,IACzD,EAAC,IAAI,SAAS,MAAM,OAAO,wBAAwB,SAAS,EAAC;AAAA,MACjE;AAAA,IACD,CAAC;AAAA,EACF;AAEA,WAAS,mBACR,OACA,UACA,SACA,gBACC;AACD,QAAI,EAAC,OAAO,MAAK,IAAI;AAErB,QAAI,IAAI;AACR,UAAM,QAAQ,CAAC,UAAe;AAC7B,UAAI,CAAC,MAAO,IAAI,KAAK,GAAG;AACvB,cAAM,OAAO,SAAS,OAAO,CAAC,CAAC,CAAC;AAChC,gBAAQ,KAAK;AAAA,UACZ,IAAI;AAAA,UACJ;AAAA,UACA;AAAA,QACD,CAAC;AACD,uBAAe,QAAQ;AAAA,UACtB,IAAI;AAAA,UACJ;AAAA,UACA;AAAA,QACD,CAAC;AAAA,MACF;AACA;AAAA,IACD,CAAC;AACD,QAAI;AACJ,UAAO,QAAQ,CAAC,UAAe;AAC9B,UAAI,CAAC,MAAM,IAAI,KAAK,GAAG;AACtB,cAAM,OAAO,SAAS,OAAO,CAAC,CAAC,CAAC;AAChC,gBAAQ,KAAK;AAAA,UACZ,IAAI;AAAA,UACJ;AAAA,UACA;AAAA,QACD,CAAC;AACD,uBAAe,QAAQ;AAAA,UACtB,IAAI;AAAA,UACJ;AAAA,UACA;AAAA,QACD,CAAC;AAAA,MACF;AACA;AAAA,IACD,CAAC;AAAA,EACF;AAEA,WAAS,4BACR,WACA,aACA,OACO;AACP,UAAM,EAAC,UAAU,gBAAe,IAAI;AACpC,aAAU,KAAK;AAAA,MACd,IAAI;AAAA,MACJ,MAAM,CAAC;AAAA,MACP,OAAO,gBAAgB,UAAU,SAAY;AAAA,IAC9C,CAAC;AACD,oBAAiB,KAAK;AAAA,MACrB,IAAI;AAAA,MACJ,MAAM,CAAC;AAAA,MACP,OAAO;AAAA,IACR,CAAC;AAAA,EACF;AAEA,WAAS,cAAiB,OAAU,SAA8B;AACjE,YAAQ,QAAQ,WAAS;AACxB,YAAM,EAAC,MAAM,GAAE,IAAI;AAEnB,UAAI,OAAY;AAChB,eAAS,IAAI,GAAG,IAAI,KAAK,SAAS,GAAG,KAAK;AACzC,cAAM,aAAa,YAAY,IAAI;AACnC,YAAI,IAAI,KAAK,CAAC;AACd,YAAI,OAAO,MAAM,YAAY,OAAO,MAAM,UAAU;AACnD,cAAI,KAAK;AAAA,QACV;AAGA,aACE,iCAAkC,kCAClC,MAAM,eAAe,MAAM;AAE5B,cAAI,cAAc,CAAC;AACpB,YAAI,WAAW,IAAI,KAAK,MAAM;AAAW,cAAI,cAAc,CAAC;AAC5D,eAAO,IAAI,MAAM,CAAC;AAClB,YAAI,CAAC,YAAY,IAAI;AAAG,cAAI,cAAc,GAAG,KAAK,KAAK,GAAG,CAAC;AAAA,MAC5D;AAEA,YAAM,OAAO,YAAY,IAAI;AAC7B,YAAM,QAAQ,oBAAoB,MAAM,KAAK;AAC7C,YAAM,MAAM,KAAK,KAAK,SAAS,CAAC;AAChC,cAAQ,IAAI;AAAA,QACX,KAAK;AACJ,kBAAQ,MAAM;AAAA,YACb;AACC,qBAAO,KAAK,IAAI,KAAK,KAAK;AAAA,YAE3B;AACC,kBAAI,WAAW;AAAA,YAChB;AAKC,qBAAQ,KAAK,GAAG,IAAI;AAAA,UACtB;AAAA,QACD,KAAK;AACJ,kBAAQ,MAAM;AAAA,YACb;AACC,qBAAO,QAAQ,MACZ,KAAK,KAAK,KAAK,IACf,KAAK,OAAO,KAAY,GAAG,KAAK;AAAA,YACpC;AACC,qBAAO,KAAK,IAAI,KAAK,KAAK;AAAA,YAC3B;AACC,qBAAO,KAAK,IAAI,KAAK;AAAA,YACtB;AACC,qBAAQ,KAAK,GAAG,IAAI;AAAA,UACtB;AAAA,QACD,KAAK;AACJ,kBAAQ,MAAM;AAAA,YACb;AACC,qBAAO,KAAK,OAAO,KAAY,CAAC;AAAA,YACjC;AACC,qBAAO,KAAK,OAAO,GAAG;AAAA,YACvB;AACC,qBAAO,KAAK,OAAO,MAAM,KAAK;AAAA,YAC/B;AACC,qBAAO,OAAO,KAAK,GAAG;AAAA,UACxB;AAAA,QACD;AACC,cAAI,cAAc,GAAG,EAAE;AAAA,MACzB;AAAA,IACD,CAAC;AAED,WAAO;AAAA,EACR;AAMA,WAAS,oBAAoB,KAAU;AACtC,QAAI,CAAC,YAAY,GAAG;AAAG,aAAO;AAC9B,QAAI,QAAQ,GAAG;AAAG,aAAO,IAAI,IAAI,mBAAmB;AACpD,QAAI,MAAM,GAAG;AACZ,aAAO,IAAI;AAAA,QACV,MAAM,KAAK,IAAI,QAAQ,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,oBAAoB,CAAC,CAAC,CAAC;AAAA,MACtE;AACD,QAAI,MAAM,GAAG;AAAG,aAAO,IAAI,IAAI,MAAM,KAAK,GAAG,EAAE,IAAI,mBAAmB,CAAC;AACvE,UAAM,SAAS,OAAO,OAAO,eAAe,GAAG,CAAC;AAChD,eAAW,OAAO;AAAK,aAAO,GAAG,IAAI,oBAAoB,IAAI,GAAG,CAAC;AACjE,QAAI,IAAI,KAAK,SAAS;AAAG,aAAO,SAAS,IAAI,IAAI,SAAS;AAC1D,WAAO;AAAA,EACR;AAEA,WAAS,wBAA2B,KAAW;AAC9C,QAAI,QAAQ,GAAG,GAAG;AACjB,aAAO,oBAAoB,GAAG;AAAA,IAC/B;AAAO,aAAO;AAAA,EACf;AAEA,aAAW,eAAe;AAAA,IACzB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD,CAAC;AACF;;;ACxZO,SAAS,eAAe;AAC9B,QAAM,iBAAiB,IAAI;AAAA,IAG1B,YAAY,QAAgB,QAAqB;AAChD,YAAM;AACN,WAAK,WAAW,IAAI;AAAA,QACnB;AAAA,QACA,SAAS;AAAA,QACT,QAAQ,SAAS,OAAO,SAAS,gBAAgB;AAAA,QACjD,WAAW;AAAA,QACX,YAAY;AAAA,QACZ,OAAO;AAAA,QACP,WAAW;AAAA,QACX,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,WAAW;AAAA,QACX,UAAU;AAAA,QACV,YAAY,CAAC;AAAA,MACd;AAAA,IACD;AAAA,IAEA,IAAI,OAAe;AAClB,aAAO,OAAO,KAAK,WAAW,CAAC,EAAE;AAAA,IAClC;AAAA,IAEA,IAAI,KAAmB;AACtB,aAAO,OAAO,KAAK,WAAW,CAAC,EAAE,IAAI,GAAG;AAAA,IACzC;AAAA,IAEA,IAAI,KAAU,OAAY;AACzB,YAAM,QAAkB,KAAK,WAAW;AACxC,sBAAgB,KAAK;AACrB,UAAI,CAAC,OAAO,KAAK,EAAE,IAAI,GAAG,KAAK,OAAO,KAAK,EAAE,IAAI,GAAG,MAAM,OAAO;AAChE,uBAAe,KAAK;AACpB,oBAAY,KAAK;AACjB,cAAM,UAAW,IAAI,KAAK,IAAI;AAC9B,cAAM,MAAO,IAAI,KAAK,KAAK;AAC3B,cAAM,UAAW,IAAI,KAAK,IAAI;AAC9B,6BAAqB,OAAO,KAAK,KAAK;AAAA,MACvC;AACA,aAAO;AAAA,IACR;AAAA,IAEA,OAAO,KAAmB;AACzB,UAAI,CAAC,KAAK,IAAI,GAAG,GAAG;AACnB,eAAO;AAAA,MACR;AAEA,YAAM,QAAkB,KAAK,WAAW;AACxC,sBAAgB,KAAK;AACrB,qBAAe,KAAK;AACpB,kBAAY,KAAK;AACjB,UAAI,MAAM,MAAM,IAAI,GAAG,GAAG;AACzB,cAAM,UAAW,IAAI,KAAK,KAAK;AAAA,MAChC,OAAO;AACN,cAAM,UAAW,OAAO,GAAG;AAAA,MAC5B;AACA,YAAM,MAAO,OAAO,GAAG;AACvB,aAAO;AAAA,IACR;AAAA,IAEA,QAAQ;AACP,YAAM,QAAkB,KAAK,WAAW;AACxC,sBAAgB,KAAK;AACrB,UAAI,OAAO,KAAK,EAAE,MAAM;AACvB,uBAAe,KAAK;AACpB,oBAAY,KAAK;AACjB,cAAM,YAAY,oBAAI,IAAI;AAC1B,aAAK,MAAM,OAAO,SAAO;AACxB,gBAAM,UAAW,IAAI,KAAK,KAAK;AAAA,QAChC,CAAC;AACD,cAAM,MAAO,MAAM;AAAA,MACpB;AAAA,IACD;AAAA,IAEA,QAAQ,IAA+C,SAAe;AACrE,YAAM,QAAkB,KAAK,WAAW;AACxC,aAAO,KAAK,EAAE,QAAQ,CAAC,QAAa,KAAU,SAAc;AAC3D,WAAG,KAAK,SAAS,KAAK,IAAI,GAAG,GAAG,KAAK,IAAI;AAAA,MAC1C,CAAC;AAAA,IACF;AAAA,IAEA,IAAI,KAAe;AAClB,YAAM,QAAkB,KAAK,WAAW;AACxC,sBAAgB,KAAK;AACrB,YAAM,QAAQ,OAAO,KAAK,EAAE,IAAI,GAAG;AACnC,UAAI,MAAM,cAAc,CAAC,YAAY,KAAK,GAAG;AAC5C,eAAO;AAAA,MACR;AACA,UAAI,UAAU,MAAM,MAAM,IAAI,GAAG,GAAG;AACnC,eAAO;AAAA,MACR;AAEA,YAAM,QAAQ,YAAY,MAAM,QAAQ,OAAO,OAAO,GAAG;AACzD,qBAAe,KAAK;AACpB,YAAM,MAAO,IAAI,KAAK,KAAK;AAC3B,aAAO;AAAA,IACR;AAAA,IAEA,OAA8B;AAC7B,aAAO,OAAO,KAAK,WAAW,CAAC,EAAE,KAAK;AAAA,IACvC;AAAA,IAEA,SAAgC;AAC/B,YAAM,WAAW,KAAK,KAAK;AAC3B,aAAO;AAAA,QACN,CAAC,OAAO,QAAQ,GAAG,MAAM,KAAK,OAAO;AAAA,QACrC,MAAM,MAAM;AACX,gBAAM,IAAI,SAAS,KAAK;AAExB,cAAI,EAAE;AAAM,mBAAO;AACnB,gBAAM,QAAQ,KAAK,IAAI,EAAE,KAAK;AAC9B,iBAAO;AAAA,YACN,MAAM;AAAA,YACN;AAAA,UACD;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,IAEA,UAAwC;AACvC,YAAM,WAAW,KAAK,KAAK;AAC3B,aAAO;AAAA,QACN,CAAC,OAAO,QAAQ,GAAG,MAAM,KAAK,QAAQ;AAAA,QACtC,MAAM,MAAM;AACX,gBAAM,IAAI,SAAS,KAAK;AAExB,cAAI,EAAE;AAAM,mBAAO;AACnB,gBAAM,QAAQ,KAAK,IAAI,EAAE,KAAK;AAC9B,iBAAO;AAAA,YACN,MAAM;AAAA,YACN,OAAO,CAAC,EAAE,OAAO,KAAK;AAAA,UACvB;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,IAEA,EAxIC,aAwIA,OAAO,SAAQ,IAAI;AACnB,aAAO,KAAK,QAAQ;AAAA,IACrB;AAAA,EACD;AAEA,WAAS,UACR,QACA,QACgB;AAEhB,UAAM,MAAM,IAAI,SAAS,QAAQ,MAAM;AACvC,WAAO,CAAC,KAAY,IAAI,WAAW,CAAC;AAAA,EACrC;AAEA,WAAS,eAAe,OAAiB;AACxC,QAAI,CAAC,MAAM,OAAO;AACjB,YAAM,YAAY,oBAAI,IAAI;AAC1B,YAAM,QAAQ,IAAI,IAAI,MAAM,KAAK;AAAA,IAClC;AAAA,EACD;AAEA,QAAM,iBAAiB,IAAI;AAAA,IAE1B,YAAY,QAAgB,QAAqB;AAChD,YAAM;AACN,WAAK,WAAW,IAAI;AAAA,QACnB;AAAA,QACA,SAAS;AAAA,QACT,QAAQ,SAAS,OAAO,SAAS,gBAAgB;AAAA,QACjD,WAAW;AAAA,QACX,YAAY;AAAA,QACZ,OAAO;AAAA,QACP,OAAO;AAAA,QACP,QAAQ;AAAA,QACR,SAAS,oBAAI,IAAI;AAAA,QACjB,UAAU;AAAA,QACV,WAAW;AAAA,QACX,WAAW;AAAA,QACX,YAAY,CAAC;AAAA,MACd;AAAA,IACD;AAAA,IAEA,IAAI,OAAe;AAClB,aAAO,OAAO,KAAK,WAAW,CAAC,EAAE;AAAA,IAClC;AAAA,IAEA,IAAI,OAAqB;AACxB,YAAM,QAAkB,KAAK,WAAW;AACxC,sBAAgB,KAAK;AAErB,UAAI,CAAC,MAAM,OAAO;AACjB,eAAO,MAAM,MAAM,IAAI,KAAK;AAAA,MAC7B;AACA,UAAI,MAAM,MAAM,IAAI,KAAK;AAAG,eAAO;AACnC,UAAI,MAAM,QAAQ,IAAI,KAAK,KAAK,MAAM,MAAM,IAAI,MAAM,QAAQ,IAAI,KAAK,CAAC;AACvE,eAAO;AACR,aAAO;AAAA,IACR;AAAA,IAEA,IAAI,OAAiB;AACpB,YAAM,QAAkB,KAAK,WAAW;AACxC,sBAAgB,KAAK;AACrB,UAAI,CAAC,KAAK,IAAI,KAAK,GAAG;AACrB,uBAAe,KAAK;AACpB,oBAAY,KAAK;AACjB,cAAM,MAAO,IAAI,KAAK;AACtB,6BAAqB,OAAO,OAAO,KAAK;AAAA,MACzC;AACA,aAAO;AAAA,IACR;AAAA,IAEA,OAAO,OAAiB;AACvB,UAAI,CAAC,KAAK,IAAI,KAAK,GAAG;AACrB,eAAO;AAAA,MACR;AAEA,YAAM,QAAkB,KAAK,WAAW;AACxC,sBAAgB,KAAK;AACrB,qBAAe,KAAK;AACpB,kBAAY,KAAK;AACjB,aACC,MAAM,MAAO,OAAO,KAAK,MACxB,MAAM,QAAQ,IAAI,KAAK,IACrB,MAAM,MAAO,OAAO,MAAM,QAAQ,IAAI,KAAK,CAAC;AAAA;AAAA,QACjB;AAAA;AAAA,IAEhC;AAAA,IAEA,QAAQ;AACP,YAAM,QAAkB,KAAK,WAAW;AACxC,sBAAgB,KAAK;AACrB,UAAI,OAAO,KAAK,EAAE,MAAM;AACvB,uBAAe,KAAK;AACpB,oBAAY,KAAK;AACjB,cAAM,MAAO,MAAM;AAAA,MACpB;AAAA,IACD;AAAA,IAEA,SAAgC;AAC/B,YAAM,QAAkB,KAAK,WAAW;AACxC,sBAAgB,KAAK;AACrB,qBAAe,KAAK;AACpB,aAAO,MAAM,MAAO,OAAO;AAAA,IAC5B;AAAA,IAEA,UAAwC;AACvC,YAAM,QAAkB,KAAK,WAAW;AACxC,sBAAgB,KAAK;AACrB,qBAAe,KAAK;AACpB,aAAO,MAAM,MAAO,QAAQ;AAAA,IAC7B;AAAA,IAEA,OAA8B;AAC7B,aAAO,KAAK,OAAO;AAAA,IACpB;AAAA,IAEA,EA9FC,aA8FA,OAAO,SAAQ,IAAI;AACnB,aAAO,KAAK,OAAO;AAAA,IACpB;AAAA,IAEA,QAAQ,IAAS,SAAe;AAC/B,YAAM,WAAW,KAAK,OAAO;AAC7B,UAAI,SAAS,SAAS,KAAK;AAC3B,aAAO,CAAC,OAAO,MAAM;AACpB,WAAG,KAAK,SAAS,OAAO,OAAO,OAAO,OAAO,IAAI;AACjD,iBAAS,SAAS,KAAK;AAAA,MACxB;AAAA,IACD;AAAA,EACD;AACA,WAAS,UACR,QACA,QACgB;AAEhB,UAAMC,OAAM,IAAI,SAAS,QAAQ,MAAM;AACvC,WAAO,CAACA,MAAYA,KAAI,WAAW,CAAC;AAAA,EACrC;AAEA,WAAS,eAAe,OAAiB;AACxC,QAAI,CAAC,MAAM,OAAO;AAEjB,YAAM,QAAQ,oBAAI,IAAI;AACtB,YAAM,MAAM,QAAQ,WAAS;AAC5B,YAAI,YAAY,KAAK,GAAG;AACvB,gBAAM,QAAQ,YAAY,MAAM,QAAQ,OAAO,OAAO,KAAK;AAC3D,gBAAM,QAAQ,IAAI,OAAO,KAAK;AAC9B,gBAAM,MAAO,IAAI,KAAK;AAAA,QACvB,OAAO;AACN,gBAAM,MAAO,IAAI,KAAK;AAAA,QACvB;AAAA,MACD,CAAC;AAAA,IACF;AAAA,EACD;AAEA,WAAS,gBAAgB,OAA+C;AACvE,QAAI,MAAM;AAAU,UAAI,GAAG,KAAK,UAAU,OAAO,KAAK,CAAC,CAAC;AAAA,EACzD;AAEA,WAAS,eAAe,QAAoB;AAG3C,QAAI,OAAO,yBAA0B,OAAO,OAAO;AAClD,YAAM,OAAO,IAAI,IAAI,OAAO,KAAK;AACjC,aAAO,MAAM,MAAM;AACnB,WAAK,QAAQ,WAAS;AACrB,eAAO,MAAO,IAAI,SAAS,KAAK,CAAC;AAAA,MAClC,CAAC;AAAA,IACF;AAAA,EACD;AAEA,aAAW,cAAc,EAAC,WAAW,WAAW,eAAc,CAAC;AAChE;;;ACzOO,SAAS,qBAAqB;AACpC,QAAM,mBAAmB,oBAAI,IAAyB,CAAC,SAAS,SAAS,CAAC;AAE1E,QAAM,gBAAgB,oBAAI,IAAyB,CAAC,QAAQ,KAAK,CAAC;AAElE,QAAM,2BAA2B,oBAAI,IAAyB;AAAA,IAC7D,GAAG;AAAA,IACH,GAAG;AAAA,EACJ,CAAC;AAED,QAAM,qBAAqB,oBAAI,IAAyB,CAAC,WAAW,MAAM,CAAC;AAG3E,QAAM,mBAAmB,oBAAI,IAAyB;AAAA,IACrD,GAAG;AAAA,IACH,GAAG;AAAA,IACH;AAAA,EACD,CAAC;AAED,QAAM,eAAe,oBAAI,IAA4B,CAAC,QAAQ,UAAU,CAAC;AAEzE,QAAM,uBAAuB,oBAAI,IAA4B;AAAA,IAC5D;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,GAAG;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD,CAAC;AAGD,WAAS,sBACR,QACgC;AAChC,WAAO,iBAAiB,IAAI,MAAa;AAAA,EAC1C;AAEA,WAAS,yBACR,QACmC;AACnC,WAAO,qBAAqB,IAAI,MAAa;AAAA,EAC9C;AAEA,WAAS,uBACR,QACiC;AACjC,WAAO,sBAAsB,MAAM,KAAK,yBAAyB,MAAM;AAAA,EACxE;AAEA,WAAS,eACR,OACA,QACC;AACD,UAAM,kBAAkB;AAAA,EACzB;AAEA,WAAS,cAAc,OAAwB;AAC9C,UAAM,kBAAkB;AAAA,EACzB;AAGA,WAAS,mBACR,OACA,WACA,aAAa,MACT;AACJ,gBAAY,KAAK;AACjB,UAAM,SAAS,UAAU;AACzB,gBAAY,KAAK;AACjB,QAAI;AAAY,YAAM,UAAW,IAAI,UAAU,IAAI;AACnD,WAAO;AAAA,EACR;AAEA,WAAS,yBAAyB,OAAwB;AACzD,UAAM,wBAAwB;AAAA,EAC/B;AAEA,WAAS,oBAAoB,OAAe,QAAwB;AACnE,QAAI,QAAQ,GAAG;AACd,aAAO,KAAK,IAAI,SAAS,OAAO,CAAC;AAAA,IAClC;AACA,WAAO,KAAK,IAAI,OAAO,MAAM;AAAA,EAC9B;AAWA,WAAS,sBACR,OACA,QACA,MACC;AACD,WAAO,mBAAmB,OAAO,MAAM;AACtC,YAAM,SAAU,MAAM,MAAe,MAAM,EAAE,GAAG,IAAI;AAGpD,UAAI,iBAAiB,IAAI,MAA6B,GAAG;AACxD,iCAAyB,KAAK;AAAA,MAC/B;AAGA,aAAO,yBAAyB,IAAI,MAA6B,IAC9D,SACA,MAAM;AAAA,IACV,CAAC;AAAA,EACF;AAWA,WAAS,0BACR,OACA,QACA,MACC;AACD,WAAO;AAAA,MACN;AAAA,MACA,MAAM;AACL;AAAC,QAAC,MAAM,MAAe,MAAM,EAAE,GAAG,IAAI;AACtC,iCAAyB,KAAK;AAC9B,eAAO,MAAM;AAAA,MACd;AAAA,MACA;AAAA,IACD;AAAA,EACD;AAkBA,WAAS,wBACR,OACA,gBACC;AACD,WAAO,SAAS,qBAAqB,MAAa;AAGjD,YAAM,SAAS;AACf,qBAAe,OAAO,MAAM;AAE5B,UAAI;AAEH,YAAI,sBAAsB,MAAM,GAAG;AAElC,cAAI,yBAAyB,IAAI,MAAM,GAAG;AACzC,mBAAO,sBAAsB,OAAO,QAAQ,IAAI;AAAA,UACjD;AACA,cAAI,mBAAmB,IAAI,MAAM,GAAG;AACnC,mBAAO,0BAA0B,OAAO,QAAQ,IAAI;AAAA,UACrD;AAEA,cAAI,WAAW,UAAU;AACxB,kBAAM,MAAM;AAAA,cAAmB;AAAA,cAAO,MACrC,MAAM,MAAO,OAAO,GAAI,IAAmC;AAAA,YAC5D;AACA,qCAAyB,KAAK;AAC9B,mBAAO;AAAA,UACR;AAAA,QACD,OAAO;AAEN,iBAAO,2BAA2B,OAAO,QAAQ,IAAI;AAAA,QACtD;AAAA,MACD,UAAE;AAED,sBAAc,KAAK;AAAA,MACpB;AAAA,IACD;AAAA,EACD;AA4BA,WAAS,2BACR,OACA,QACA,MACC;AACD,UAAM,SAAS,OAAO,KAAK;AAG3B,QAAI,WAAW,UAAU;AACxB,YAAM,YAAY,KAAK,CAAC;AACxB,YAAM,SAAgB,CAAC;AAGvB,eAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,YAAI,UAAU,OAAO,CAAC,GAAG,GAAG,MAAM,GAAG;AAEpC,iBAAO,KAAK,MAAM,OAAO,CAAC,CAAC;AAAA,QAC5B;AAAA,MACD;AAEA,aAAO;AAAA,IACR;AAEA,QAAI,aAAa,IAAI,MAAM,GAAG;AAC7B,YAAM,YAAY,KAAK,CAAC;AACxB,YAAM,YAAY,WAAW;AAC7B,YAAM,OAAO,YAAY,IAAI;AAC7B,YAAM,QAAQ,YAAY,IAAI,OAAO,SAAS;AAE9C,eAAS,IAAI,OAAO,KAAK,KAAK,IAAI,OAAO,QAAQ,KAAK,MAAM;AAC3D,YAAI,UAAU,OAAO,CAAC,GAAG,GAAG,MAAM,GAAG;AACpC,iBAAO,MAAM,OAAO,CAAC;AAAA,QACtB;AAAA,MACD;AACA,aAAO;AAAA,IACR;AAEA,QAAI,WAAW,SAAS;AACvB,YAAM,WAAW,KAAK,CAAC,KAAK;AAC5B,YAAM,SAAS,KAAK,CAAC,KAAK,OAAO;AAGjC,YAAM,QAAQ,oBAAoB,UAAU,OAAO,MAAM;AACzD,YAAM,MAAM,oBAAoB,QAAQ,OAAO,MAAM;AAErD,YAAM,SAAgB,CAAC;AAGvB,eAAS,IAAI,OAAO,IAAI,KAAK,KAAK;AACjC,eAAO,KAAK,MAAM,OAAO,CAAC,CAAC;AAAA,MAC5B;AAEA,aAAO;AAAA,IACR;AAOA,WAAO,OAAO,MAAsC,EAAE,GAAG,IAAI;AAAA,EAC9D;AAEA,aAAW,oBAAoB;AAAA,IAC9B;AAAA,IACA;AAAA,IACA;AAAA,EACD,CAAC;AACF;;;AZhXA,IAAM,QAAQ,IAAIC,OAAM;AAqBjB,IAAM,UAAoC,MAAM;AAMhD,IAAM,qBAA0D,sBAAM,mBAAmB;AAAA,EAC/F;AACD;AAOO,IAAM,gBAAgC,sBAAM,cAAc,KAAK,KAAK;AAOpE,IAAM,0BAA0C,sBAAM,wBAAwB;AAAA,EACpF;AACD;AAQO,IAAM,wBAAwC,sBAAM,sBAAsB;AAAA,EAChF;AACD;AAOO,IAAM,eAA+B,sBAAM,aAAa,KAAK,KAAK;AAMlE,IAAM,cAA8B,sBAAM,YAAY,KAAK,KAAK;AAUhE,IAAM,cAA8B,sBAAM,YAAY,KAAK,KAAK;AAQhE,IAAI,YAAY,CAAI,UAAuB;AAO3C,IAAI,gBAAgB,CAAI,UAA2B;","names":["Immer","immer","current","Immer","base","rootScope","isSet","current","set","Immer"]}