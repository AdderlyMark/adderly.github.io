{"version":3,"sources":["../../src/immer.ts","../../src/utils/env.ts","../../src/utils/errors.ts","../../src/utils/common.ts","../../src/utils/plugins.ts","../../src/core/scope.ts","../../src/core/finalize.ts","../../src/core/proxy.ts","../../src/core/immerClass.ts","../../src/core/current.ts","../../src/plugins/patches.ts","../../src/plugins/mapset.ts","../../src/plugins/arrayMethods.ts"],"sourcesContent":["import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tWritableDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\tProducer,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze,\n\tObjectish,\n\tStrictMode\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = /* @__PURE__ */ immer.produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to enable strict shallow copy.\n *\n * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n */\nexport const setUseStrictShallowCopy = /* @__PURE__ */ immer.setUseStrictShallowCopy.bind(\n\timmer\n)\n\n/**\n * Pass false to use loose iteration that only processes enumerable string properties.\n * This skips symbols and non-enumerable properties for maximum performance.\n *\n * By default, strict iteration is enabled (includes all own properties).\n */\nexport const setUseStrictIteration = /* @__PURE__ */ immer.setUseStrictIteration.bind(\n\timmer\n)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = /* @__PURE__ */ immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = /* @__PURE__ */ immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport let castDraft = <T>(value: T): Draft<T> => value as any\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport let castImmutable = <T>(value: T): Immutable<T> => value as any\n\nexport {Immer}\n\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableArrayMethods} from \"./plugins/arrayMethods\"\n","// Should be no imports here!\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n","import {isFunction} from \"../internal\"\n\nexport const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// All error codes, starting by 0:\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t\t\t\t\"Immer forbids circular references\",\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t\t\t\t\"Immer only supports deleting array indices\",\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\t\t\t\t// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n\t\t\t\t// See Patches.ts for additional errors\n\t\t  ]\n\t\t: []\n\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst e = errors[error]\n\t\tconst msg = isFunction(e) ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tArchType,\n\tdie,\n\tStrictMode\n} from \"../internal\"\n\nconst O = Object\n\nexport const getPrototypeOf = O.getPrototypeOf\n\nexport const CONSTRUCTOR = \"constructor\"\nexport const PROTOTYPE = \"prototype\"\n\nexport const CONFIGURABLE = \"configurable\"\nexport const ENUMERABLE = \"enumerable\"\nexport const WRITABLE = \"writable\"\nexport const VALUE = \"value\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport let isDraft = (value: any): boolean => !!value && !!value[DRAFT_STATE]\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tisArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value[CONSTRUCTOR]?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = O[PROTOTYPE][CONSTRUCTOR].toString()\nconst cachedCtorStrings = new WeakMap()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || !isObjectish(value)) return false\n\tconst proto = getPrototypeOf(value)\n\tif (proto === null || proto === O[PROTOTYPE]) return true\n\n\tconst Ctor = O.hasOwnProperty.call(proto, CONSTRUCTOR) && proto[CONSTRUCTOR]\n\tif (Ctor === Object) return true\n\n\tif (!isFunction(Ctor)) return false\n\n\tlet ctorString = cachedCtorStrings.get(Ctor)\n\tif (ctorString === undefined) {\n\t\tctorString = Function.toString.call(Ctor)\n\t\tcachedCtorStrings.set(Ctor, ctorString)\n\t}\n\n\treturn ctorString === objectCtorString\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/**\n * Each iterates a map, set or array.\n * Or, if any other kind of object, all of its own properties.\n *\n * @param obj The object to iterate over\n * @param iter The iterator function\n * @param strict When true (default), includes symbols and non-enumerable properties.\n *               When false, uses looseiteration over only enumerable string properties.\n */\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tstrict?: boolean\n): void\nexport function each(obj: any, iter: any, strict: boolean = true) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\t// If strict, we do a full iteration including symbols and non-enumerable properties\n\t\t// Otherwise, we only iterate enumerable string properties for performance\n\t\tconst keys = strict ? Reflect.ownKeys(obj) : O.keys(obj)\n\t\tkeys.forEach(key => {\n\t\t\titer(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_\n\t\t: isArray(thing)\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/*#__PURE__*/\nexport let has = (\n\tthing: any,\n\tprop: PropertyKey,\n\ttype = getArchtype(thing)\n): boolean =>\n\ttype === ArchType.Map\n\t\t? thing.has(prop)\n\t\t: O[PROTOTYPE].hasOwnProperty.call(thing, prop)\n\n/*#__PURE__*/\nexport let get = (\n\tthing: AnyMap | AnyObject,\n\tprop: PropertyKey,\n\ttype = getArchtype(thing)\n): any =>\n\t// @ts-ignore\n\ttype === ArchType.Map ? thing.get(prop) : thing[prop]\n\n/*#__PURE__*/\nexport let set = (\n\tthing: any,\n\tpropOrOldValue: PropertyKey,\n\tvalue: any,\n\ttype = getArchtype(thing)\n) => {\n\tif (type === ArchType.Map) thing.set(propOrOldValue, value)\n\telse if (type === ArchType.Set) {\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\nexport let isArray = Array.isArray\n\n/*#__PURE__*/\nexport let isMap = (target: any): target is AnyMap => target instanceof Map\n\n/*#__PURE__*/\nexport let isSet = (target: any): target is AnySet => target instanceof Set\n\nexport let isObjectish = (target: any) => typeof target === \"object\"\n\nexport let isFunction = (target: any): target is Function =>\n\ttypeof target === \"function\"\n\nexport let isBoolean = (target: any): target is boolean =>\n\ttypeof target === \"boolean\"\n\nexport function isArrayIndex(value: string | number): value is number | string {\n\tconst n = +value\n\treturn Number.isInteger(n) && String(n) === value\n}\n\nexport let getProxyDraft = <T extends any>(value: T): ImmerState | null => {\n\tif (!isObjectish(value)) return null\n\treturn (value as {[DRAFT_STATE]: any})?.[DRAFT_STATE]\n}\n\n/*#__PURE__*/\nexport let latest = (state: ImmerState): any => state.copy_ || state.base_\n\nexport let getValue = <T extends object>(value: T): T => {\n\tconst proxyDraft = getProxyDraft(value)\n\treturn proxyDraft ? proxyDraft.copy_ ?? proxyDraft.base_ : value\n}\n\nexport let getFinalValue = (state: ImmerState): any =>\n\tstate.modified_ ? state.copy_ : state.base_\n\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: StrictMode) {\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\tif (isArray(base)) return Array[PROTOTYPE].slice.call(base)\n\n\tconst isPlain = isPlainObject(base)\n\n\tif (strict === true || (strict === \"class_only\" && !isPlain)) {\n\t\t// Perform a strict copy\n\t\tconst descriptors = O.getOwnPropertyDescriptors(base)\n\t\tdelete descriptors[DRAFT_STATE as any]\n\t\tlet keys = Reflect.ownKeys(descriptors)\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key: any = keys[i]\n\t\t\tconst desc = descriptors[key]\n\t\t\tif (desc[WRITABLE] === false) {\n\t\t\t\tdesc[WRITABLE] = true\n\t\t\t\tdesc[CONFIGURABLE] = true\n\t\t\t}\n\t\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t\t// with libraries that trap values, like mobx or vue\n\t\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\t\tif (desc.get || desc.set)\n\t\t\t\tdescriptors[key] = {\n\t\t\t\t\t[CONFIGURABLE]: true,\n\t\t\t\t\t[WRITABLE]: true, // could live with !!desc.set as well here...\n\t\t\t\t\t[ENUMERABLE]: desc[ENUMERABLE],\n\t\t\t\t\t[VALUE]: base[key]\n\t\t\t\t}\n\t\t}\n\t\treturn O.create(getPrototypeOf(base), descriptors)\n\t} else {\n\t\t// perform a sloppy copy\n\t\tconst proto = getPrototypeOf(base)\n\t\tif (proto !== null && isPlain) {\n\t\t\treturn {...base} // assumption: better inner class optimization than the assign below\n\t\t}\n\t\tconst obj = O.create(proto)\n\t\treturn O.assign(obj, base)\n\t}\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tO.defineProperties(obj, {\n\t\t\tset: dontMutateMethodOverride,\n\t\t\tadd: dontMutateMethodOverride,\n\t\t\tclear: dontMutateMethodOverride,\n\t\t\tdelete: dontMutateMethodOverride\n\t\t})\n\t}\n\tO.freeze(obj)\n\tif (deep)\n\t\t// See #590, don't recurse into non-enumerable / Symbol properties when freezing\n\t\t// So use Object.values (only string-like, enumerables) instead of each()\n\t\teach(\n\t\t\tobj,\n\t\t\t(_key, value) => {\n\t\t\t\tfreeze(value, true)\n\t\t\t},\n\t\t\tfalse\n\t\t)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nconst dontMutateMethodOverride = {\n\t[VALUE]: dontMutateFrozenCollections\n}\n\nexport function isFrozen(obj: any): boolean {\n\t// Fast path: primitives and null/undefined are always \"frozen\"\n\tif (obj === null || !isObjectish(obj)) return true\n\treturn O.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie,\n\tImmerScope,\n\tProxyArrayState\n} from \"../internal\"\n\nexport const PluginMapSet = \"MapSet\"\nexport const PluginPatches = \"Patches\"\nexport const PluginArrayMethods = \"ArrayMethods\"\n\nexport type PatchesPlugin = {\n\tgeneratePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\trootScope: ImmerScope\n\t): void\n\tgenerateReplacementPatches_(\n\t\tbase: any,\n\t\treplacement: any,\n\t\trootScope: ImmerScope\n\t): void\n\tapplyPatches_<T>(draft: T, patches: readonly Patch[]): T\n\tgetPath: (state: ImmerState) => PatchPath | null\n}\n\nexport type MapSetPlugin = {\n\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): [T, ImmerState]\n\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): [T, ImmerState]\n\tfixSetContents: (state: ImmerState) => void\n}\n\nexport type ArrayMethodsPlugin = {\n\tcreateMethodInterceptor: (state: ProxyArrayState, method: string) => Function\n\tisArrayOperationMethod: (method: string) => boolean\n\tisMutatingArrayMethod: (method: string) => boolean\n}\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: PatchesPlugin\n\tMapSet?: MapSetPlugin\n\tArrayMethods?: ArrayMethodsPlugin\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport let isPluginLoaded = <K extends keyof Plugins>(pluginKey: K): boolean =>\n\t!!plugins[pluginKey]\n\nexport let clearPlugin = <K extends keyof Plugins>(pluginKey: K): void => {\n\tdelete plugins[pluginKey]\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map\n\tcopy_: AnyMap | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tArchType,\n\tgetPlugin,\n\tPatchesPlugin,\n\tMapSetPlugin,\n\tisPluginLoaded,\n\tPluginMapSet,\n\tPluginPatches,\n\tArrayMethodsPlugin,\n\tPluginArrayMethods\n} from \"../internal\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tpatchPlugin_?: PatchesPlugin\n\tmapSetPlugin_?: MapSetPlugin\n\tarrayMethodsPlugin_?: ArrayMethodsPlugin\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n\thandledSet_: Set<any>\n\tprocessedForPatches_: Set<any>\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport let getCurrentScope = () => currentScope!\n\nlet createScope = (\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope => ({\n\tdrafts_: [],\n\tparent_,\n\timmer_,\n\t// Whenever the modified draft contains a draft from another scope, we\n\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\tcanAutoFreeze_: true,\n\tunfinalizedDrafts_: 0,\n\thandledSet_: new Set(),\n\tprocessedForPatches_: new Set(),\n\tmapSetPlugin_: isPluginLoaded(PluginMapSet)\n\t\t? getPlugin(PluginMapSet)\n\t\t: undefined,\n\tarrayMethodsPlugin_: isPluginLoaded(PluginArrayMethods)\n\t\t? getPlugin(PluginArrayMethods)\n\t\t: undefined\n})\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tscope.patchPlugin_ = getPlugin(PluginPatches) // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport let enterScope = (immer: Immer) =>\n\t(currentScope = createScope(currentScope, immer))\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tget,\n\tPatch,\n\tlatest,\n\tprepareCopy,\n\tgetFinalValue,\n\tgetValue,\n\tProxyArrayState\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t}\n\t\tconst {patchPlugin_} = scope\n\t\tif (patchPlugin_) {\n\t\t\tpatchPlugin_.generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft)\n\t}\n\n\tmaybeFreeze(scope, result, true)\n\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\tif (!state) {\n\t\tconst finalValue = handleValue(value, rootScope.handledSet_, rootScope)\n\t\treturn finalValue\n\t}\n\n\t// Never finalize drafts owned by another scope\n\tif (!isSameScope(state, rootScope)) {\n\t\treturn value\n\t}\n\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\treturn state.base_\n\t}\n\n\tif (!state.finalized_) {\n\t\t// Execute all registered draft finalization callbacks\n\t\tconst {callbacks_} = state\n\t\tif (callbacks_) {\n\t\t\twhile (callbacks_.length > 0) {\n\t\t\t\tconst callback = callbacks_.pop()!\n\t\t\t\tcallback(rootScope)\n\t\t\t}\n\t\t}\n\n\t\tgeneratePatchesAndFinalize(state, rootScope)\n\t}\n\n\t// By now the root copy has been fully updated throughout its tree\n\treturn state.copy_\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n\nfunction markStateFinalized(state: ImmerState) {\n\tstate.finalized_ = true\n\tstate.scope_.unfinalizedDrafts_--\n}\n\nlet isSameScope = (state: ImmerState, rootScope: ImmerScope) =>\n\tstate.scope_ === rootScope\n\n// A reusable empty array to avoid allocations\nconst EMPTY_LOCATIONS_RESULT: (string | symbol | number)[] = []\n\n// Updates all references to a draft in its parent to the finalized value.\n// This handles cases where the same draft appears multiple times in the parent, or has been moved around.\nexport function updateDraftInParent(\n\tparent: ImmerState,\n\tdraftValue: any,\n\tfinalizedValue: any,\n\toriginalKey?: string | number | symbol\n): void {\n\tconst parentCopy = latest(parent)\n\tconst parentType = parent.type_\n\n\t// Fast path: Check if draft is still at original key\n\tif (originalKey !== undefined) {\n\t\tconst currentValue = get(parentCopy, originalKey, parentType)\n\t\tif (currentValue === draftValue) {\n\t\t\t// Still at original location, just update it\n\t\t\tset(parentCopy, originalKey, finalizedValue, parentType)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Slow path: Build reverse mapping of all children\n\t// to their indices in the parent, so that we can\n\t// replace all locations where this draft appears.\n\t// We only have to build this once per parent.\n\tif (!parent.draftLocations_) {\n\t\tconst draftLocations = (parent.draftLocations_ = new Map())\n\n\t\t// Use `each` which works on Arrays, Maps, and Objects\n\t\teach(parentCopy, (key, value) => {\n\t\t\tif (isDraft(value)) {\n\t\t\t\tconst keys = draftLocations.get(value) || []\n\t\t\t\tkeys.push(key)\n\t\t\t\tdraftLocations.set(value, keys)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Look up all locations where this draft appears\n\tconst locations =\n\t\tparent.draftLocations_.get(draftValue) ?? EMPTY_LOCATIONS_RESULT\n\n\t// Update all locations\n\tfor (const location of locations) {\n\t\tset(parentCopy, location, finalizedValue, parentType)\n\t}\n}\n\n// Register a callback to finalize a child draft when the parent draft is finalized.\n// This assumes there is a parent -> child relationship between the two drafts,\n// and we have a key to locate the child in the parent.\nexport function registerChildFinalizationCallback(\n\tparent: ImmerState,\n\tchild: ImmerState,\n\tkey: string | number | symbol\n) {\n\tparent.callbacks_.push(function childCleanup(rootScope) {\n\t\tconst state: ImmerState = child\n\n\t\t// Can only continue if this is a draft owned by this scope\n\t\tif (!state || !isSameScope(state, rootScope)) {\n\t\t\treturn\n\t\t}\n\n\t\t// Handle potential set value finalization first\n\t\trootScope.mapSetPlugin_?.fixSetContents(state)\n\n\t\tconst finalizedValue = getFinalValue(state)\n\n\t\t// Update all locations in the parent that referenced this draft\n\t\tupdateDraftInParent(parent, state.draft_ ?? state, finalizedValue, key)\n\n\t\tgeneratePatchesAndFinalize(state, rootScope)\n\t})\n}\n\nfunction generatePatchesAndFinalize(state: ImmerState, rootScope: ImmerScope) {\n\tconst shouldFinalize =\n\t\tstate.modified_ &&\n\t\t!state.finalized_ &&\n\t\t(state.type_ === ArchType.Set ||\n\t\t\t(state.type_ === ArchType.Array &&\n\t\t\t\t(state as ProxyArrayState).allIndicesReassigned_) ||\n\t\t\t(state.assigned_?.size ?? 0) > 0)\n\n\tif (shouldFinalize) {\n\t\tconst {patchPlugin_} = rootScope\n\t\tif (patchPlugin_) {\n\t\t\tconst basePath = patchPlugin_!.getPath(state)\n\n\t\t\tif (basePath) {\n\t\t\t\tpatchPlugin_!.generatePatches_(state, basePath, rootScope)\n\t\t\t}\n\t\t}\n\n\t\tmarkStateFinalized(state)\n\t}\n}\n\nexport function handleCrossReference(\n\ttarget: ImmerState,\n\tkey: string | number | symbol,\n\tvalue: any\n) {\n\tconst {scope_} = target\n\t// Check if value is a draft from this scope\n\tif (isDraft(value)) {\n\t\tconst state: ImmerState = value[DRAFT_STATE]\n\t\tif (isSameScope(state, scope_)) {\n\t\t\t// Register callback to update this location when the draft finalizes\n\n\t\t\tstate.callbacks_.push(function crossReferenceCleanup() {\n\t\t\t\t// Update the target location with finalized value\n\t\t\t\tprepareCopy(target)\n\n\t\t\t\tconst finalizedValue = getFinalValue(state)\n\n\t\t\t\tupdateDraftInParent(target, value, finalizedValue, key)\n\t\t\t})\n\t\t}\n\t} else if (isDraftable(value)) {\n\t\t// Handle non-draft objects that might contain drafts\n\t\ttarget.callbacks_.push(function nestedDraftCleanup() {\n\t\t\tconst targetCopy = latest(target)\n\n\t\t\t// For Sets, check if value is still in the set\n\t\t\tif (target.type_ === ArchType.Set) {\n\t\t\t\tif (targetCopy.has(value)) {\n\t\t\t\t\t// Process the value to replace any nested drafts\n\t\t\t\t\thandleValue(value, scope_.handledSet_, scope_)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Maps/objects\n\t\t\t\tif (get(targetCopy, key, target.type_) === value) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tscope_.drafts_.length > 1 &&\n\t\t\t\t\t\t((target as Exclude<ImmerState, SetState>).assigned_!.get(key) ??\n\t\t\t\t\t\t\tfalse) === true &&\n\t\t\t\t\t\ttarget.copy_\n\t\t\t\t\t) {\n\t\t\t\t\t\t// This might be a non-draft value that has drafts\n\t\t\t\t\t\t// inside. We do need to recurse here to handle those.\n\t\t\t\t\t\thandleValue(\n\t\t\t\t\t\t\tget(target.copy_, key, target.type_),\n\t\t\t\t\t\t\tscope_.handledSet_,\n\t\t\t\t\t\t\tscope_\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nexport function handleValue(\n\ttarget: any,\n\thandledSet: Set<any>,\n\trootScope: ImmerScope\n) {\n\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t// This benefits especially adding large data tree's without further processing.\n\t\t// See add-data.js perf test\n\t\treturn target\n\t}\n\n\t// Skip if already handled, frozen, or not draftable\n\tif (\n\t\tisDraft(target) ||\n\t\thandledSet.has(target) ||\n\t\t!isDraftable(target) ||\n\t\tisFrozen(target)\n\t) {\n\t\treturn target\n\t}\n\n\thandledSet.add(target)\n\n\t// Process ALL properties/entries\n\teach(target, (key, value) => {\n\t\tif (isDraft(value)) {\n\t\t\tconst state: ImmerState = value[DRAFT_STATE]\n\t\t\tif (isSameScope(state, rootScope)) {\n\t\t\t\t// Replace draft with finalized value\n\n\t\t\t\tconst updatedValue = getFinalValue(state)\n\n\t\t\t\tset(target, key, updatedValue, target.type_)\n\n\t\t\t\tmarkStateFinalized(state)\n\t\t\t}\n\t\t} else if (isDraftable(value)) {\n\t\t\t// Recursively handle nested values\n\t\t\thandleValue(value, handledSet, rootScope)\n\t\t}\n\t})\n\n\treturn target\n}\n","import {\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\thandleCrossReference,\n\tWRITABLE,\n\tCONFIGURABLE,\n\tENUMERABLE,\n\tVALUE,\n\tisArray,\n\tisArrayIndex\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ArchType.Object\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ArchType.Array\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n\toperationMethod?: string\n\tallIndicesReassigned_?: boolean\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): [Drafted<T, ProxyState>, ProxyState] {\n\tconst baseIsArray = isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: baseIsArray ? ArchType.Array : (ArchType.Object as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\t// actually instantiated in `prepareCopy()`\n\t\tassigned_: undefined,\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false,\n\t\t// `callbacks` actually gets assigned in `createProxy`\n\t\tcallbacks_: undefined as any\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (baseIsArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn [proxy as any, state]\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tlet arrayPlugin = state.scope_.arrayMethodsPlugin_\n\t\tconst isArrayWithStringProp =\n\t\t\tstate.type_ === ArchType.Array && typeof prop === \"string\"\n\t\t// Intercept array methods so that we can override\n\t\t// behavior and skip proxy creation for perf\n\t\tif (isArrayWithStringProp) {\n\t\t\tif (arrayPlugin?.isArrayOperationMethod(prop)) {\n\t\t\t\treturn arrayPlugin.createMethodInterceptor(state, prop)\n\t\t\t}\n\t\t}\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop, state.type_)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\n\t\t// During mutating array operations, defer proxy creation for array elements\n\t\t// This optimization avoids creating unnecessary proxies during sort/reverse\n\t\tif (\n\t\t\tisArrayWithStringProp &&\n\t\t\t(state as ProxyArrayState).operationMethod &&\n\t\t\tarrayPlugin?.isMutatingArrayMethod(\n\t\t\t\t(state as ProxyArrayState).operationMethod!\n\t\t\t) &&\n\t\t\tisArrayIndex(prop)\n\t\t) {\n\t\t\t// Return raw value during mutating operations, create proxy only if modified\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\t// Ensure array keys are always numbers\n\t\t\tconst childKey = state.type_ === ArchType.Array ? +(prop as string) : prop\n\t\t\tconst childDraft = createProxy(state.scope_, value, state, childKey)\n\n\t\t\treturn (state.copy_![childKey] = childDraft)\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_!.set(prop, false)\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (\n\t\t\t\tis(value, current) &&\n\t\t\t\t(value !== undefined || has(state.base_, prop, state.type_))\n\t\t\t)\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// special case: NaN\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_!.set(prop, true)\n\n\t\thandleCrossReference(state, prop, value)\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\tprepareCopy(state)\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_!.set(prop, false)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tstate.assigned_!.delete(prop)\n\t\t}\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\t[WRITABLE]: true,\n\t\t\t[CONFIGURABLE]: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\t[ENUMERABLE]: desc[ENUMERABLE],\n\t\t\t[VALUE]: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\n// Use `for..in` instead of `each` to work around a weird\n// prod test suite issue\nfor (let key in objectTraps) {\n\tlet fn = objectTraps[key as keyof typeof objectTraps] as Function\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\tconst args = arguments\n\t\targs[0] = args[0][0]\n\t\treturn fn.apply(this, args)\n\t}\n}\narrayTraps.deleteProperty = function(state, prop) {\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? VALUE in desc\n\t\t\t? desc[VALUE]\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: ImmerState) {\n\tif (!state.copy_) {\n\t\t// Actually create the `assigned_` map now that we\n\t\t// know this is a modified draft.\n\t\tstate.assigned_ = new Map()\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent,\n\tImmerScope,\n\tregisterChildFinalizationCallback,\n\tArchType,\n\tMapSetPlugin,\n\tAnyMap,\n\tAnySet,\n\tisObjectish,\n\tisFunction,\n\tisBoolean,\n\tPluginMapSet,\n\tPluginPatches\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport type StrictMode = boolean | \"class_only\"\n\nexport class Immer implements ProducersFns {\n\tautoFreeze_: boolean = true\n\tuseStrictShallowCopy_: StrictMode = false\n\tuseStrictIteration_: boolean = false\n\n\tconstructor(config?: {\n\t\tautoFreeze?: boolean\n\t\tuseStrictShallowCopy?: StrictMode\n\t\tuseStrictIteration?: boolean\n\t}) {\n\t\tif (isBoolean(config?.autoFreeze)) this.setAutoFreeze(config!.autoFreeze)\n\t\tif (isBoolean(config?.useStrictShallowCopy))\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t\tif (isBoolean(config?.useStrictIteration))\n\t\t\tthis.setUseStrictIteration(config!.useStrictIteration)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (isFunction(base) && !isFunction(recipe)) {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (!isFunction(recipe)) die(6)\n\t\tif (patchListener !== undefined && !isFunction(patchListener)) die(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(scope, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || !isObjectish(base)) {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(PluginPatches).generateReplacementPatches_(base, result, {\n\t\t\t\t\tpatches_: p,\n\t\t\t\t\tinversePatches_: ip\n\t\t\t\t} as ImmerScope) // dummy scope\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(1, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// curried invocation\n\t\tif (isFunction(base)) {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(scope, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (!state || !state.isManual_) die(9)\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to enable strict shallow copy.\n\t *\n\t * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n\t */\n\tsetUseStrictShallowCopy(value: StrictMode) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\t/**\n\t * Pass false to use faster iteration that skips non-enumerable properties\n\t * but still handles symbols for compatibility.\n\t *\n\t * By default, strict iteration is enabled (includes all own properties).\n\t */\n\tsetUseStrictIteration(value: boolean) {\n\t\tthis.useStrictIteration_ = value\n\t}\n\n\tshouldUseStrictIteration(): boolean {\n\t\treturn this.useStrictIteration_\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: readonly Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(PluginPatches).applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\trootScope: ImmerScope,\n\tvalue: T,\n\tparent?: ImmerState,\n\tkey?: string | number | symbol\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\t// returning a tuple here lets us skip a proxy access\n\t// to DRAFT_STATE later\n\tconst [draft, state] = isMap(value)\n\t\t? getPlugin(PluginMapSet).proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(PluginMapSet).proxySet_(value, parent)\n\t\t: createProxyProxy(value, parent)\n\n\tconst scope = parent?.scope_ ?? getCurrentScope()\n\tscope.drafts_.push(draft)\n\n\t// Ensure the parent callbacks are passed down so we actually\n\t// track all callbacks added throughout the tree\n\tstate.callbacks_ = parent?.callbacks_ ?? []\n\tstate.key_ = key\n\n\tif (parent && key !== undefined) {\n\t\tregisterChildFinalizationCallback(parent, state, key)\n\t} else {\n\t\t// It's a root draft, register it with the scope\n\t\tstate.callbacks_.push(function rootDraftCleanup(rootScope) {\n\t\t\trootScope.mapSetPlugin_?.fixSetContents(state)\n\n\t\t\tconst {patchPlugin_} = rootScope\n\n\t\t\tif (state.modified_ && patchPlugin_) {\n\t\t\t\tpatchPlugin_.generatePatches_(state, [], rootScope)\n\t\t\t}\n\t\t})\n\t}\n\n\treturn draft as any\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tlet strict = true // Default to strict for compatibility\n\tif (state) {\n\t\tif (!state.modified_) return state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t\tstrict = state.scope_.immer_.shouldUseStrictIteration()\n\t} else {\n\t\tcopy = shallowCopy(value, true)\n\t}\n\t// recurse\n\teach(\n\t\tcopy,\n\t\t(key, childValue) => {\n\t\t\tset(copy, key, currentImpl(childValue))\n\t\t},\n\t\tstrict\n\t)\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\treturn copy\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tProxyArrayState,\n\tMapState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tgetPrototypeOf,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tArchType,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING,\n\terrors,\n\tDRAFT_STATE,\n\tgetProxyDraft,\n\tImmerScope,\n\tisObjectish,\n\tisFunction,\n\tCONSTRUCTOR,\n\tPluginPatches,\n\tisArray,\n\tPROTOTYPE\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst errorOffset = 16\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\terrors.push(\n\t\t\t'Sets cannot have \"replace\" patches.',\n\t\t\tfunction(op: string) {\n\t\t\t\treturn \"Unsupported patch operation: \" + op\n\t\t\t},\n\t\t\tfunction(path: string) {\n\t\t\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t\t\t},\n\t\t\t\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t\t)\n\t}\n\n\tfunction getPath(state: ImmerState, path: PatchPath = []): PatchPath | null {\n\t\t// Step 1: Check if state has a stored key\n\t\tif (state.key_ !== undefined) {\n\t\t\t// Step 2: Validate the key is still valid in parent\n\n\t\t\tconst parentCopy = state.parent_!.copy_ ?? state.parent_!.base_\n\t\t\tconst proxyDraft = getProxyDraft(get(parentCopy, state.key_!))\n\t\t\tconst valueAtKey = get(parentCopy, state.key_!)\n\n\t\t\tif (valueAtKey === undefined) {\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\t// Check if the value at the key is still related to this draft\n\t\t\t// It should be either the draft itself, the base, or the copy\n\t\t\tif (\n\t\t\t\tvalueAtKey !== state.draft_ &&\n\t\t\t\tvalueAtKey !== state.base_ &&\n\t\t\t\tvalueAtKey !== state.copy_\n\t\t\t) {\n\t\t\t\treturn null // Value was replaced with something else\n\t\t\t}\n\t\t\tif (proxyDraft != null && proxyDraft.base_ !== state.base_) {\n\t\t\t\treturn null // Different draft\n\t\t\t}\n\n\t\t\t// Step 3: Handle Set case specially\n\t\t\tconst isSet = state.parent_!.type_ === ArchType.Set\n\t\t\tlet key: string | number\n\n\t\t\tif (isSet) {\n\t\t\t\t// For Sets, find the index in the drafts_ map\n\t\t\t\tconst setParent = state.parent_ as SetState\n\t\t\t\tkey = Array.from(setParent.drafts_.keys()).indexOf(state.key_)\n\t\t\t} else {\n\t\t\t\tkey = state.key_ as string | number\n\t\t\t}\n\n\t\t\t// Step 4: Validate key still exists in parent\n\t\t\tif (!((isSet && parentCopy.size > key) || has(parentCopy, key))) {\n\t\t\t\treturn null // Key deleted\n\t\t\t}\n\n\t\t\t// Step 5: Add key to path\n\t\t\tpath.push(key)\n\t\t}\n\n\t\t// Step 6: Recurse to parent if exists\n\t\tif (state.parent_) {\n\t\t\treturn getPath(state.parent_, path)\n\t\t}\n\n\t\t// Step 7: At root - reverse path and validate\n\t\tpath.reverse()\n\n\t\ttry {\n\t\t\t// Validate path can be resolved from ROOT\n\t\t\tresolvePath(state.copy_, path)\n\t\t} catch (e) {\n\t\t\treturn null // Path invalid\n\t\t}\n\n\t\treturn path\n\t}\n\n\t// NEW: Add resolvePath helper function\n\tfunction resolvePath(base: any, path: PatchPath): any {\n\t\tlet current = base\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst key = path[i]\n\t\t\tcurrent = get(current, key)\n\t\t\tif (!isObjectish(current) || current === null) {\n\t\t\t\tthrow new Error(`Cannot resolve path at '${path.join(\"/\")}'`)\n\t\t\t}\n\t\t}\n\t\treturn current\n\t}\n\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tscope: ImmerScope\n\t): void {\n\t\tif (state.scope_.processedForPatches_.has(state)) {\n\t\t\treturn\n\t\t}\n\n\t\tstate.scope_.processedForPatches_.add(state)\n\n\t\tconst {patches_, inversePatches_} = scope\n\n\t\tswitch (state.type_) {\n\t\t\tcase ArchType.Object:\n\t\t\tcase ArchType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t\tcase ArchType.Array:\n\t\t\t\treturn generateArrayPatches(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t\tcase ArchType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\tconst allReassigned = state.allIndicesReassigned_ === true\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tconst copiedItem = copy_[i]\n\t\t\tconst baseItem = base_[i]\n\n\t\t\tconst isAssigned = allReassigned || assigned_?.get(i.toString())\n\t\t\tif (isAssigned && copiedItem !== baseItem) {\n\t\t\t\tconst childState = copiedItem?.[DRAFT_STATE]\n\t\t\t\tif (childState && childState.modified_) {\n\t\t\t\t\t// Skip - let the child generate its own patches\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copiedItem)\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(baseItem)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tfor (let i = copy_.length - 1; base_.length <= i; --i) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tinversePatches.push({\n\t\t\t\top: REMOVE,\n\t\t\t\tpath\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_, type_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key, type_)\n\t\t\tconst value = get(copy_!, key, type_)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(\n\t\t\t\top === REMOVE\n\t\t\t\t\t? {op, path}\n\t\t\t\t\t: {op, path, value: clonePatchValueIfNeeded(value)}\n\t\t\t)\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tscope: ImmerScope\n\t): void {\n\t\tconst {patches_, inversePatches_} = scope\n\t\tpatches_!.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches_!.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: readonly Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tlet p = path[i]\n\t\t\t\tif (typeof p !== \"string\" && typeof p !== \"number\") {\n\t\t\t\t\tp = \"\" + p\n\t\t\t\t}\n\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === ArchType.Object || parentType === ArchType.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === CONSTRUCTOR)\n\t\t\t\t)\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tif (isFunction(base) && p === PROTOTYPE) die(errorOffset + 3)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (!isObjectish(base)) die(errorOffset + 2, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\tdie(errorOffset)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(errorOffset + 1, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(PluginPatches, {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_,\n\t\tgetPath\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tdie,\n\tArchType,\n\teach,\n\tgetValue,\n\tPluginMapSet,\n\thandleCrossReference\n} from \"../internal\"\n\nexport function enableMapSet() {\n\tclass DraftMap extends Map {\n\t\t[DRAFT_STATE]: MapState\n\n\t\tconstructor(target: AnyMap, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false,\n\t\t\t\tcallbacks_: []\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tset(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\thandleCrossReference(state, key, value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tforEach(cb: (value: any, key: any, self: any) => void, thisArg?: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tget(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_, value, state, key)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.entries()\n\t\t}\n\t}\n\n\tfunction proxyMap_<T extends AnyMap>(\n\t\ttarget: T,\n\t\tparent?: ImmerState\n\t): [T, MapState] {\n\t\t// @ts-ignore\n\t\tconst map = new DraftMap(target, parent)\n\t\treturn [map as any, map[DRAFT_STATE]]\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tclass DraftSet extends Set {\n\t\t[DRAFT_STATE]: SetState\n\t\tconstructor(target: AnySet, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tcallbacks_: []\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tadd(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t\thandleCrossReference(state, value, value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tforEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\t}\n\tfunction proxySet_<T extends AnySet>(\n\t\ttarget: T,\n\t\tparent?: ImmerState\n\t): [T, SetState] {\n\t\t// @ts-ignore\n\t\tconst set = new DraftSet(target, parent)\n\t\treturn [set as any, set[DRAFT_STATE]]\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_, value, state, value)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tfunction fixSetContents(target: ImmerState) {\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// To preserve insertion order in all cases we then clear the set\n\t\tif (target.type_ === ArchType.Set && target.copy_) {\n\t\t\tconst copy = new Set(target.copy_)\n\t\t\ttarget.copy_.clear()\n\t\t\tcopy.forEach(value => {\n\t\t\t\ttarget.copy_!.add(getValue(value))\n\t\t\t})\n\t\t}\n\t}\n\n\tloadPlugin(PluginMapSet, {proxyMap_, proxySet_, fixSetContents})\n}\n","import {\n\tPluginArrayMethods,\n\tlatest,\n\tloadPlugin,\n\tmarkChanged,\n\tprepareCopy,\n\tProxyArrayState\n} from \"../internal\"\n\n/**\n * Methods that directly modify the array in place.\n * These operate on the copy without creating per-element proxies:\n * - `push`, `pop`: Add/remove from end\n * - `shift`, `unshift`: Add/remove from start (marks all indices reassigned)\n * - `splice`: Add/remove at arbitrary position (marks all indices reassigned)\n * - `reverse`, `sort`: Reorder elements (marks all indices reassigned)\n */\ntype MutatingArrayMethod =\n\t| \"push\"\n\t| \"pop\"\n\t| \"shift\"\n\t| \"unshift\"\n\t| \"splice\"\n\t| \"reverse\"\n\t| \"sort\"\n\n/**\n * Methods that read from the array without modifying it.\n * These fall into distinct categories based on return semantics:\n *\n * **Subset operations** (return drafts - mutations propagate):\n * - `filter`, `slice`: Return array of draft proxies\n * - `find`, `findLast`: Return single draft proxy or undefined\n *\n * **Transform operations** (return base values - mutations don't track):\n * - `concat`, `flat`: Create new structures, not subsets of original\n *\n * **Primitive-returning** (no draft needed):\n * - `findIndex`, `findLastIndex`, `indexOf`, `lastIndexOf`: Return numbers\n * - `some`, `every`, `includes`: Return booleans\n * - `join`, `toString`, `toLocaleString`: Return strings\n */\ntype NonMutatingArrayMethod =\n\t| \"filter\"\n\t| \"slice\"\n\t| \"concat\"\n\t| \"flat\"\n\t| \"find\"\n\t| \"findIndex\"\n\t| \"findLast\"\n\t| \"findLastIndex\"\n\t| \"some\"\n\t| \"every\"\n\t| \"indexOf\"\n\t| \"lastIndexOf\"\n\t| \"includes\"\n\t| \"join\"\n\t| \"toString\"\n\t| \"toLocaleString\"\n\n/** Union of all array operation methods handled by the plugin. */\nexport type ArrayOperationMethod = MutatingArrayMethod | NonMutatingArrayMethod\n\n/**\n * Enables optimized array method handling for Immer drafts.\n *\n * This plugin overrides array methods to avoid unnecessary Proxy creation during iteration,\n * significantly improving performance for array-heavy operations.\n *\n * **Mutating methods** (push, pop, shift, unshift, splice, sort, reverse):\n * Operate directly on the copy without creating per-element proxies.\n *\n * **Non-mutating methods** fall into categories:\n * - **Subset operations** (filter, slice, find, findLast): Return draft proxies - mutations track\n * - **Transform operations** (concat, flat): Return base values - mutations don't track\n * - **Primitive-returning** (indexOf, includes, some, every, etc.): Return primitives\n *\n * **Important**: Callbacks for overridden methods receive base values, not drafts.\n * This is the core performance optimization.\n *\n * @example\n * ```ts\n * import { enableArrayMethods, produce } from \"immer\"\n *\n * enableArrayMethods()\n *\n * const next = produce(state, draft => {\n *   // Optimized - no proxy creation per element\n *   draft.items.sort((a, b) => a.value - b.value)\n *\n *   // filter returns drafts - mutations propagate\n *   const filtered = draft.items.filter(x => x.value > 5)\n *   filtered[0].value = 999 // Affects draft.items[originalIndex]\n * })\n * ```\n *\n * @see https://immerjs.github.io/immer/array-methods\n */\nexport function enableArrayMethods() {\n\tconst SHIFTING_METHODS = new Set<MutatingArrayMethod>([\"shift\", \"unshift\"])\n\n\tconst QUEUE_METHODS = new Set<MutatingArrayMethod>([\"push\", \"pop\"])\n\n\tconst RESULT_RETURNING_METHODS = new Set<MutatingArrayMethod>([\n\t\t...QUEUE_METHODS,\n\t\t...SHIFTING_METHODS\n\t])\n\n\tconst REORDERING_METHODS = new Set<MutatingArrayMethod>([\"reverse\", \"sort\"])\n\n\t// Optimized method detection using array-based lookup\n\tconst MUTATING_METHODS = new Set<MutatingArrayMethod>([\n\t\t...RESULT_RETURNING_METHODS,\n\t\t...REORDERING_METHODS,\n\t\t\"splice\"\n\t])\n\n\tconst FIND_METHODS = new Set<NonMutatingArrayMethod>([\"find\", \"findLast\"])\n\n\tconst NON_MUTATING_METHODS = new Set<NonMutatingArrayMethod>([\n\t\t\"filter\",\n\t\t\"slice\",\n\t\t\"concat\",\n\t\t\"flat\",\n\t\t...FIND_METHODS,\n\t\t\"findIndex\",\n\t\t\"findLastIndex\",\n\t\t\"some\",\n\t\t\"every\",\n\t\t\"indexOf\",\n\t\t\"lastIndexOf\",\n\t\t\"includes\",\n\t\t\"join\",\n\t\t\"toString\",\n\t\t\"toLocaleString\"\n\t])\n\n\t// Type guard for method detection\n\tfunction isMutatingArrayMethod(\n\t\tmethod: string\n\t): method is MutatingArrayMethod {\n\t\treturn MUTATING_METHODS.has(method as any)\n\t}\n\n\tfunction isNonMutatingArrayMethod(\n\t\tmethod: string\n\t): method is NonMutatingArrayMethod {\n\t\treturn NON_MUTATING_METHODS.has(method as any)\n\t}\n\n\tfunction isArrayOperationMethod(\n\t\tmethod: string\n\t): method is ArrayOperationMethod {\n\t\treturn isMutatingArrayMethod(method) || isNonMutatingArrayMethod(method)\n\t}\n\n\tfunction enterOperation(\n\t\tstate: ProxyArrayState,\n\t\tmethod: ArrayOperationMethod\n\t) {\n\t\tstate.operationMethod = method\n\t}\n\n\tfunction exitOperation(state: ProxyArrayState) {\n\t\tstate.operationMethod = undefined\n\t}\n\n\t// Shared utility functions for array method handlers\n\tfunction executeArrayMethod<T>(\n\t\tstate: ProxyArrayState,\n\t\toperation: () => T,\n\t\tmarkLength = true\n\t): T {\n\t\tprepareCopy(state)\n\t\tconst result = operation()\n\t\tmarkChanged(state)\n\t\tif (markLength) state.assigned_!.set(\"length\", true)\n\t\treturn result\n\t}\n\n\tfunction markAllIndicesReassigned(state: ProxyArrayState) {\n\t\tstate.allIndicesReassigned_ = true\n\t}\n\n\tfunction normalizeSliceIndex(index: number, length: number): number {\n\t\tif (index < 0) {\n\t\t\treturn Math.max(length + index, 0)\n\t\t}\n\t\treturn Math.min(index, length)\n\t}\n\n\t/**\n\t * Handles mutating operations that add/remove elements (push, pop, shift, unshift, splice).\n\t *\n\t * Operates directly on `state.copy_` without creating per-element proxies.\n\t * For shifting methods (shift, unshift), marks all indices as reassigned since\n\t * indices shift.\n\t *\n\t * @returns For push/pop/shift/unshift: the native method result. For others: the draft.\n\t */\n\tfunction handleSimpleOperation(\n\t\tstate: ProxyArrayState,\n\t\tmethod: string,\n\t\targs: any[]\n\t) {\n\t\treturn executeArrayMethod(state, () => {\n\t\t\tconst result = (state.copy_! as any)[method](...args)\n\n\t\t\t// Handle index reassignment for shifting methods\n\t\t\tif (SHIFTING_METHODS.has(method as MutatingArrayMethod)) {\n\t\t\t\tmarkAllIndicesReassigned(state)\n\t\t\t}\n\n\t\t\t// Return appropriate value based on method\n\t\t\treturn RESULT_RETURNING_METHODS.has(method as MutatingArrayMethod)\n\t\t\t\t? result\n\t\t\t\t: state.draft_\n\t\t})\n\t}\n\n\t/**\n\t * Handles reordering operations (reverse, sort) that change element order.\n\t *\n\t * Operates directly on `state.copy_` and marks all indices as reassigned\n\t * since element positions change. Does not mark length as changed since\n\t * these operations preserve array length.\n\t *\n\t * @returns The draft proxy for method chaining.\n\t */\n\tfunction handleReorderingOperation(\n\t\tstate: ProxyArrayState,\n\t\tmethod: string,\n\t\targs: any[]\n\t) {\n\t\treturn executeArrayMethod(\n\t\t\tstate,\n\t\t\t() => {\n\t\t\t\t;(state.copy_! as any)[method](...args)\n\t\t\t\tmarkAllIndicesReassigned(state)\n\t\t\t\treturn state.draft_\n\t\t\t},\n\t\t\tfalse\n\t\t) // Don't mark length as changed\n\t}\n\n\t/**\n\t * Creates an interceptor function for a specific array method.\n\t *\n\t * The interceptor wraps array method calls to:\n\t * 1. Set `state.operationMethod` flag during execution (allows proxy `get` trap\n\t *    to detect we're inside an optimized method and skip proxy creation)\n\t * 2. Route to appropriate handler based on method type\n\t * 3. Clean up the operation flag in `finally` block\n\t *\n\t * The `operationMethod` flag is the key mechanism that enables the proxy's `get`\n\t * trap to return base values instead of creating nested proxies during iteration.\n\t *\n\t * @param state - The proxy array state\n\t * @param originalMethod - Name of the array method being intercepted\n\t * @returns Interceptor function that handles the method call\n\t */\n\tfunction createMethodInterceptor(\n\t\tstate: ProxyArrayState,\n\t\toriginalMethod: string\n\t) {\n\t\treturn function interceptedMethod(...args: any[]) {\n\t\t\t// Enter operation mode - this flag tells the proxy's get trap to return\n\t\t\t// base values instead of creating nested proxies during iteration\n\t\t\tconst method = originalMethod as ArrayOperationMethod\n\t\t\tenterOperation(state, method)\n\n\t\t\ttry {\n\t\t\t\t// Check if this is a mutating method\n\t\t\t\tif (isMutatingArrayMethod(method)) {\n\t\t\t\t\t// Direct method dispatch - no configuration lookup needed\n\t\t\t\t\tif (RESULT_RETURNING_METHODS.has(method)) {\n\t\t\t\t\t\treturn handleSimpleOperation(state, method, args)\n\t\t\t\t\t}\n\t\t\t\t\tif (REORDERING_METHODS.has(method)) {\n\t\t\t\t\t\treturn handleReorderingOperation(state, method, args)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (method === \"splice\") {\n\t\t\t\t\t\tconst res = executeArrayMethod(state, () =>\n\t\t\t\t\t\t\tstate.copy_!.splice(...(args as [number, number, ...any[]]))\n\t\t\t\t\t\t)\n\t\t\t\t\t\tmarkAllIndicesReassigned(state)\n\t\t\t\t\t\treturn res\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Handle non-mutating methods\n\t\t\t\t\treturn handleNonMutatingOperation(state, method, args)\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\t// Always exit operation mode - must be in finally to handle exceptions\n\t\t\t\texitOperation(state)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handles non-mutating array methods with different return semantics.\n\t *\n\t * **Subset operations** return draft proxies for mutation tracking:\n\t * - `filter`, `slice`: Return `state.draft_[i]` for each selected element\n\t * - `find`, `findLast`: Return `state.draft_[i]` for the found element\n\t *\n\t * This allows mutations on returned elements to propagate back to the draft:\n\t * ```ts\n\t * const filtered = draft.items.filter(x => x.value > 5)\n\t * filtered[0].value = 999 // Mutates draft.items[originalIndex]\n\t * ```\n\t *\n\t * **Transform operations** return base values (no draft tracking):\n\t * - `concat`, `flat`: These create NEW arrays rather than selecting subsets.\n\t *   Since the result structure differs from the original, tracking mutations\n\t *   back to specific draft indices would be impractical/impossible.\n\t *\n\t * **Primitive operations** return the native result directly:\n\t * - `indexOf`, `includes`, `some`, `every`, `join`, etc.\n\t *\n\t * @param state - The proxy array state\n\t * @param method - The non-mutating method name\n\t * @param args - Arguments passed to the method\n\t * @returns Drafts for subset operations, base values for transforms, primitives otherwise\n\t */\n\tfunction handleNonMutatingOperation(\n\t\tstate: ProxyArrayState,\n\t\tmethod: NonMutatingArrayMethod,\n\t\targs: any[]\n\t) {\n\t\tconst source = latest(state)\n\n\t\t// Methods that return arrays with selected items - need to return drafts\n\t\tif (method === \"filter\") {\n\t\t\tconst predicate = args[0]\n\t\t\tconst result: any[] = []\n\n\t\t\t// First pass: call predicate on base values to determine which items pass\n\t\t\tfor (let i = 0; i < source.length; i++) {\n\t\t\t\tif (predicate(source[i], i, source)) {\n\t\t\t\t\t// Only create draft for items that passed the predicate\n\t\t\t\t\tresult.push(state.draft_[i])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result\n\t\t}\n\n\t\tif (FIND_METHODS.has(method)) {\n\t\t\tconst predicate = args[0]\n\t\t\tconst isForward = method === \"find\"\n\t\t\tconst step = isForward ? 1 : -1\n\t\t\tconst start = isForward ? 0 : source.length - 1\n\n\t\t\tfor (let i = start; i >= 0 && i < source.length; i += step) {\n\t\t\t\tif (predicate(source[i], i, source)) {\n\t\t\t\t\treturn state.draft_[i]\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (method === \"slice\") {\n\t\t\tconst rawStart = args[0] ?? 0\n\t\t\tconst rawEnd = args[1] ?? source.length\n\n\t\t\t// Normalize negative indices\n\t\t\tconst start = normalizeSliceIndex(rawStart, source.length)\n\t\t\tconst end = normalizeSliceIndex(rawEnd, source.length)\n\n\t\t\tconst result: any[] = []\n\n\t\t\t// Return drafts for items in the slice range\n\t\t\tfor (let i = start; i < end; i++) {\n\t\t\t\tresult.push(state.draft_[i])\n\t\t\t}\n\n\t\t\treturn result\n\t\t}\n\n\t\t// For other methods, call on base array directly:\n\t\t// - indexOf, includes, join, toString: Return primitives, no draft needed\n\t\t// - concat, flat: Return NEW arrays (not subsets). Elements are base values.\n\t\t//   This is intentional - concat/flat create new data structures rather than\n\t\t//   selecting subsets of the original, making draft tracking impractical.\n\t\treturn source[method as keyof typeof Array.prototype](...args)\n\t}\n\n\tloadPlugin(PluginArrayMethods, {\n\t\tcreateMethodInterceptor,\n\t\tisArrayOperationMethod,\n\t\tisMutatingArrayMethod\n\t})\n}\n"],"mappings":"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","names":["immer_exports","__export","Immer","applyPatches","castDraft","castImmutable","createDraft","current","enableArrayMethods","enableMapSet","enablePatches","finishDraft","freeze","DRAFTABLE","isDraft","isDraftable","NOTHING","original","produce","produceWithPatches","setAutoFreeze","setUseStrictIteration","setUseStrictShallowCopy","__toCommonJS","NOTHING","DRAFTABLE","DRAFT_STATE","die","error","args","O","getPrototypeOf","CONSTRUCTOR","PROTOTYPE","CONFIGURABLE","ENUMERABLE","WRITABLE","VALUE","isDraft","value","DRAFT_STATE","isDraftable","isPlainObject","isArray","DRAFTABLE","isMap","isSet","objectCtorString","cachedCtorStrings","isObjectish","proto","Ctor","isFunction","ctorString","original","die","base_","each","obj","iter","strict","getArchtype","key","entry","index","thing","state","type_","has","prop","type","get","set","propOrOldValue","is","x","y","target","isBoolean","isArrayIndex","n","getProxyDraft","latest","copy_","getValue","proxyDraft","getFinalValue","modified_","shallowCopy","base","isPlain","descriptors","keys","desc","freeze","deep","isFrozen","dontMutateMethodOverride","_key","dontMutateFrozenCollections","PluginMapSet","PluginPatches","PluginArrayMethods","plugins","getPlugin","pluginKey","plugin","die","isPluginLoaded","loadPlugin","pluginKey","implementation","plugins","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","handledSet_","processedForPatches_","mapSetPlugin_","isPluginLoaded","PluginMapSet","getPlugin","arrayMethodsPlugin_","PluginArrayMethods","usePatchesInScope","scope","patchListener","patchPlugin_","PluginPatches","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer","draft","state","DRAFT_STATE","type_","revoke_","revoked_","processResult","result","scope","unfinalizedDrafts_","drafts_","baseDraft","DRAFT_STATE","modified_","revokeScope","die","isDraftable","finalize","patchPlugin_","generateReplacementPatches_","base_","maybeFreeze","patches_","patchListener_","inversePatches_","NOTHING","rootScope","value","isFrozen","state","handleValue","handledSet_","isSameScope","finalized_","callbacks_","generatePatchesAndFinalize","copy_","deep","parent_","immer_","autoFreeze_","canAutoFreeze_","freeze","markStateFinalized","scope_","EMPTY_LOCATIONS_RESULT","updateDraftInParent","parent","draftValue","finalizedValue","originalKey","parentCopy","latest","parentType","type_","get","set","draftLocations_","draftLocations","each","key","isDraft","keys","locations","location","registerChildFinalizationCallback","child","mapSetPlugin_","getFinalValue","draft_","allIndicesReassigned_","assigned_","basePath","generatePatches_","handleCrossReference","target","prepareCopy","targetCopy","handledSet","updatedValue","createProxyProxy","base","parent","baseIsArray","isArray","state","type_","scope_","getCurrentScope","modified_","finalized_","assigned_","parent_","base_","draft_","copy_","revoke_","isManual_","callbacks_","target","traps","objectTraps","arrayTraps","revoke","proxy","prop","DRAFT_STATE","arrayPlugin","arrayMethodsPlugin_","isArrayWithStringProp","source","latest","has","readPropFromProto","value","isDraftable","isArrayIndex","peek","prepareCopy","childKey","childDraft","createProxy","desc","getDescriptorFromProto","current","currentState","is","markChanged","handleCrossReference","owner","WRITABLE","CONFIGURABLE","ENUMERABLE","VALUE","die","getPrototypeOf","key","fn","args","draft","proto","shallowCopy","immer_","useStrictShallowCopy_","Immer","config","autoFreeze_","useStrictShallowCopy_","useStrictIteration_","base","recipe","patchListener","isFunction","defaultBase","self","args","draft","die","result","isDraftable","scope","enterScope","proxy","createProxy","hasError","revokeScope","leaveScope","usePatchesInScope","processResult","isObjectish","NOTHING","freeze","p","ip","getPlugin","PluginPatches","generateReplacementPatches_","patches_","inversePatches_","state","patches","inversePatches","isBoolean","isDraft","current","DRAFT_STATE","isManual_","scope_","value","i","patch","applyPatchesImpl","applyPatches_","rootScope","parent","key","isMap","PluginMapSet","proxyMap_","isSet","proxySet_","createProxyProxy","getCurrentScope","drafts_","callbacks_","key_","registerChildFinalizationCallback","mapSetPlugin_","patchPlugin_","modified_","generatePatches_","current","value","isDraft","die","currentImpl","isDraftable","isFrozen","state","DRAFT_STATE","copy","strict","modified_","base_","finalized_","shallowCopy","scope_","immer_","useStrictShallowCopy_","each","key","childValue","set","enablePatches","getPath","state","path","key_","parentCopy","parent_","copy_","base_","proxyDraft","getProxyDraft","get","valueAtKey","draft_","isSet","type_","key","setParent","drafts_","has","resolvePath","base","current","i","isObjectish","REPLACE","ADD","REMOVE","generatePatches_","basePath","scope","scope_","processedForPatches_","patches_","inversePatches_","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","patches","inversePatches","assigned_","allReassigned","allIndicesReassigned_","copiedItem","baseItem","childState","DRAFT_STATE","modified_","clonePatchValueIfNeeded","each","assignedValue","origValue","value","op","generateReplacementPatches_","baseValue","replacement","NOTHING","applyPatches_","draft","patch","parentType","getArchtype","p","CONSTRUCTOR","die","isFunction","PROTOTYPE","type","deepClonePatchValue","obj","isDraftable","isArray","isMap","k","v","cloned","getPrototypeOf","DRAFTABLE","isDraft","loadPlugin","PluginPatches","enableMapSet","DraftMap","target","parent","DRAFT_STATE","type_","parent_","scope_","getCurrentScope","modified_","finalized_","copy_","assigned_","base_","draft_","isManual_","revoked_","callbacks_","latest","key","value","state","assertUnrevoked","prepareMapCopy","markChanged","handleCrossReference","each","cb","thisArg","_value","_map","isDraftable","draft","createProxy","iterator","r","proxyMap_","map","DraftSet","drafts_","prepareSetCopy","result","proxySet_","set","die","fixSetContents","copy","getValue","loadPlugin","PluginMapSet","enableArrayMethods","SHIFTING_METHODS","QUEUE_METHODS","RESULT_RETURNING_METHODS","REORDERING_METHODS","MUTATING_METHODS","FIND_METHODS","NON_MUTATING_METHODS","isMutatingArrayMethod","method","isNonMutatingArrayMethod","isArrayOperationMethod","enterOperation","state","exitOperation","executeArrayMethod","operation","markLength","prepareCopy","result","markChanged","assigned_","markAllIndicesReassigned","allIndicesReassigned_","normalizeSliceIndex","index","length","handleSimpleOperation","args","copy_","draft_","handleReorderingOperation","createMethodInterceptor","originalMethod","res","handleNonMutatingOperation","source","latest","predicate","i","isForward","step","start","rawStart","rawEnd","end","loadPlugin","PluginArrayMethods","immer","Immer","produce","produceWithPatches","setAutoFreeze","setUseStrictShallowCopy","setUseStrictIteration","applyPatches","createDraft","finishDraft","castDraft","value","castImmutable"]}