"use strict";var He=Object.defineProperty;var $t=Object.getOwnPropertyDescriptor;var Yt=Object.getOwnPropertyNames;var Jt=Object.prototype.hasOwnProperty;var Gt=(e,t)=>{for(var u in t)He(e,u,{get:t[u],enumerable:!0})},Zt=(e,t,u,l)=>{if(t&&typeof t=="object"||typeof t=="function")for(let p of Yt(t))!Jt.call(e,p)&&p!==u&&He(e,p,{get:()=>t[p],enumerable:!(l=$t(t,p))||l.enumerable});return e};var Xt=e=>Zt(He({},"__esModule",{value:!0}),e);var ln={};Gt(ln,{NamedSchemaError:()=>ce,QueryStatus:()=>Ve,_NEVER:()=>Ct,buildCreateApi:()=>Le,copyWithStructuralSharing:()=>Se,coreModule:()=>_e,coreModuleName:()=>Me,createApi:()=>jt,defaultSerializeQueryArgs:()=>ke,fakeBaseQuery:()=>Ft,fetchBaseQuery:()=>pt,retry:()=>lt,setupListeners:()=>Qt,skipToken:()=>Be});module.exports=Xt(ln);var Ve=(p=>(p.uninitialized="uninitialized",p.pending="pending",p.fulfilled="fulfilled",p.rejected="rejected",p))(Ve||{}),W="uninitialized",Fe="pending",ge="fulfilled",Qe="rejected";function je(e){return{status:e,isUninitialized:e===W,isLoading:e===Fe,isSuccess:e===ge,isError:e===Qe}}var s=require("@reduxjs/toolkit");var tt=s.isPlainObject;function Se(e,t){if(e===t||!(tt(e)&&tt(t)||Array.isArray(e)&&Array.isArray(t)))return t;let u=Object.keys(t),l=Object.keys(e),p=u.length===l.length,S=Array.isArray(t)?[]:{};for(let Q of u)S[Q]=Se(e[Q],t[Q]),p&&(p=e[Q]===S[Q]);return p?e:S}function xe(e,t,u){return e.reduce((l,p,S)=>(t(p,S)&&l.push(u(p,S)),l),[]).flat()}function nt(e){return new RegExp("(^|:)//").test(e)}function rt(){return typeof document>"u"?!0:document.visibilityState!=="hidden"}function De(e){return e!=null}function ze(e){return[...e?.values()??[]].filter(De)}function it(){return typeof navigator>"u"||navigator.onLine===void 0?!0:navigator.onLine}var en=e=>e.replace(/\/$/,""),tn=e=>e.replace(/^\//,"");function at(e,t){if(!e)return t;if(!t)return e;if(nt(t))return t;let u=e.endsWith("/")||!t.startsWith("?")?"/":"";return e=en(e),t=tn(t),`${e}${u}${t}`}function ye(e,t,u){return e.has(t)?e.get(t):e.set(t,u(t)).get(t)}var Ee=()=>new Map;var ot=e=>{let t=new AbortController;return setTimeout(()=>{let u="signal timed out",l="TimeoutError";t.abort(typeof DOMException<"u"?new DOMException(u,l):Object.assign(new Error(u),{name:l}))},e),t.signal},st=(...e)=>{for(let u of e)if(u.aborted)return AbortSignal.abort(u.reason);let t=new AbortController;for(let u of e)u.addEventListener("abort",()=>t.abort(u.reason),{signal:t.signal,once:!0});return t.signal};var ut=(...e)=>fetch(...e),nn=e=>e.status>=200&&e.status<=299,rn=e=>/ion\/(vnd\.api\+)?json/.test(e.get("content-type")||"");function yt(e){if(!(0,s.isPlainObject)(e))return e;let t={...e};for(let[u,l]of Object.entries(t))l===void 0&&delete t[u];return t}var an=e=>typeof e=="object"&&((0,s.isPlainObject)(e)||Array.isArray(e)||typeof e.toJSON=="function");function pt({baseUrl:e,prepareHeaders:t=h=>h,fetchFn:u=ut,paramsSerializer:l,isJsonContentType:p=rn,jsonContentType:S="application/json",jsonReplacer:Q,timeout:k,responseHandler:M,validateStatus:x,...D}={}){return typeof fetch>"u"&&u===ut&&console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."),async(R,b,w)=>{let{getState:P,extra:f,endpoint:A,forced:B,type:y}=b,c,{url:i,headers:T=new Headers(D.headers),params:E=void 0,responseHandler:g=M??"json",validateStatus:d=x??nn,timeout:a=k,...n}=typeof R=="string"?{url:R}:R,r={...D,signal:a?st(b.signal,ot(a)):b.signal,...n};T=new Headers(yt(T)),r.headers=await t(T,{getState:P,arg:R,extra:f,endpoint:A,forced:B,type:y,extraOptions:w})||T;let o=an(r.body);if(r.body!=null&&!o&&typeof r.body!="string"&&r.headers.delete("content-type"),!r.headers.has("content-type")&&o&&r.headers.set("content-type",S),o&&p(r.headers)&&(r.body=JSON.stringify(r.body,Q)),r.headers.has("accept")||(g==="json"?r.headers.set("accept","application/json"):g==="text"&&r.headers.set("accept","text/plain, text/html, */*")),E){let O=~i.indexOf("?")?"&":"?",_=l?l(E):new URLSearchParams(yt(E));i+=O+_}i=at(e,i);let m=new Request(i,r);c={request:new Request(i,r)};let C;try{C=await u(m)}catch(O){return{error:{status:(O instanceof Error||typeof DOMException<"u"&&O instanceof DOMException)&&O.name==="TimeoutError"?"TIMEOUT_ERROR":"FETCH_ERROR",error:String(O)},meta:c}}let N=C.clone();c.response=N;let v,I="";try{let O;if(await Promise.all([h(C,g).then(_=>v=_,_=>O=_),N.text().then(_=>I=_,()=>{})]),O)throw O}catch(O){return{error:{status:"PARSING_ERROR",originalStatus:C.status,data:I,error:String(O)},meta:c}}return d(C,v)?{data:v,meta:c}:{error:{status:C.status,data:v},meta:c}};async function h(R,b){if(typeof b=="function")return b(R);if(b==="content-type"&&(b=p(R.headers)?"json":"text"),b==="json"){let w=await R.text();return w.length?JSON.parse(w):null}return R.text()}}var Z=class{constructor(t,u=void 0){this.value=t;this.meta=u}};async function on(e=0,t=5,u){let l=Math.min(e,t),p=~~((Math.random()+.4)*(300<<l));await new Promise((S,Q)=>{let k=setTimeout(()=>S(),p);if(u){let M=()=>{clearTimeout(k),Q(new Error("Aborted"))};u.aborted?(clearTimeout(k),Q(new Error("Aborted"))):u.addEventListener("abort",M,{once:!0})}})}function ct(e,t){throw Object.assign(new Z({error:e,meta:t}),{throwImmediately:!0})}function We(e){e.aborted&&ct({status:"CUSTOM_ERROR",error:"Aborted"})}var dt={},sn=(e,t)=>async(u,l,p)=>{let S=[5,(t||dt).maxRetries,(p||dt).maxRetries].filter(D=>D!==void 0),[Q]=S.slice(-1),M={maxRetries:Q,backoff:on,retryCondition:(D,h,{attempt:R})=>R<=Q,...t,...p},x=0;for(;;){We(l.signal);try{let D=await e(u,l,p);if(D.error)throw new Z(D);return D}catch(D){if(x++,D.throwImmediately){if(D instanceof Z)return D.value;throw D}if(D instanceof Z){if(!M.retryCondition(D.value.error,u,{attempt:x,baseQueryApi:l,extraOptions:p}))return D.value}else if(x>M.maxRetries)return{error:D};We(l.signal);try{await M.backoff(x,M.maxRetries,l.signal)}catch(h){throw We(l.signal),h}}}},lt=Object.assign(sn,{fail:ct});var Oe="__rtkq/",ft="online",mt="offline",un="focus",gt="focused",yn="visibilitychange",ie=(0,s.createAction)(`${Oe}${gt}`),Te=(0,s.createAction)(`${Oe}un${gt}`),ae=(0,s.createAction)(`${Oe}${ft}`),he=(0,s.createAction)(`${Oe}${mt}`),pn={onFocus:ie,onFocusLost:Te,onOnline:ae,onOffline:he},ve=!1;function Qt(e,t){function u(){let[l,p,S,Q]=[ie,Te,ae,he].map(D=>()=>e(D())),k=()=>{window.document.visibilityState==="visible"?l():p()},M=()=>{ve=!1};if(!ve&&typeof window<"u"&&window.addEventListener){let h=function(R){Object.entries(D).forEach(([b,w])=>{R?window.addEventListener(b,w,!1):window.removeEventListener(b,w)})};var x=h;let D={[un]:l,[yn]:k,[ft]:S,[mt]:Q};h(!0),ve=!0,M=()=>{h(!1),ve=!1}}return M}return t?t(e,pn):u()}var te="query",$e="mutation",Ye="infinitequery";function pe(e){return e.type===te}function Tt(e){return e.type===$e}function de(e){return e.type===Ye}function Re(e){return pe(e)||de(e)}function be(e,t,u,l,p,S){let Q=dn(e)?e(t,u,l,p):e;return Q?xe(Q,De,k=>S(Je(k))):[]}function dn(e){return typeof e=="function"}function Je(e){return typeof e=="string"?{type:e}:e}var H=require("immer");var Hn=require("@reduxjs/toolkit");function ht(e,t){return e.catch(t)}var J=(e,t)=>e.endpointDefinitions[t];var Ae=Symbol("forceQueryFn"),Pe=e=>typeof e[Ae]=="function";function Rt({serializeQueryArgs:e,queryThunk:t,infiniteQueryThunk:u,mutationThunk:l,api:p,context:S,getInternalState:Q}){let k=i=>Q(i)?.runningQueries,M=i=>Q(i)?.runningMutations,{unsubscribeQueryResult:x,removeMutationResult:D,updateSubscriptionOptions:h}=p.internalActions;return{buildInitiateQuery:B,buildInitiateInfiniteQuery:y,buildInitiateMutation:c,getRunningQueryThunk:R,getRunningMutationThunk:b,getRunningQueriesThunk:w,getRunningMutationsThunk:P};function R(i,T){return E=>{let g=J(S,i),d=e({queryArgs:T,endpointDefinition:g,endpointName:i});return k(E)?.get(d)}}function b(i,T){return E=>M(E)?.get(T)}function w(){return i=>ze(k(i))}function P(){return i=>ze(M(i))}function f(i){}function A(i,T){let E=(g,{subscribe:d=!0,forceRefetch:a,subscriptionOptions:n,[Ae]:r,...o}={})=>(m,F)=>{let C=e({queryArgs:g,endpointDefinition:T,endpointName:i}),N,v={...o,type:te,subscribe:d,forceRefetch:a,subscriptionOptions:n,endpointName:i,originalArgs:g,queryCacheKey:C,[Ae]:r};if(pe(T))N=t(v);else{let{direction:K,initialPageParam:L,refetchCachedPages:U}=o;N=u({...v,direction:K,initialPageParam:L,refetchCachedPages:U})}let I=p.endpoints[i].select(g),O=m(N),_=I(F());let{requestId:$,abort:G}=O,V=_.requestId!==$,z=k(m)?.get(C),j=()=>I(F()),q=Object.assign(r?O.then(j):V&&!z?Promise.resolve(_):Promise.all([z,O]).then(j),{arg:g,requestId:$,subscriptionOptions:n,queryCacheKey:C,abort:G,async unwrap(){let K=await q;if(K.isError)throw K.error;return K.data},refetch:K=>m(E(g,{subscribe:!1,forceRefetch:!0,...K})),unsubscribe(){d&&m(x({queryCacheKey:C,requestId:$}))},updateSubscriptionOptions(K){q.subscriptionOptions=K,m(h({endpointName:i,requestId:$,queryCacheKey:C,options:K}))}});if(!z&&!V&&!r){let K=k(m);K.set(C,q),q.then(()=>{K.delete(C)})}return q};return E}function B(i,T){return A(i,T)}function y(i,T){return A(i,T)}function c(i){return(T,{track:E=!0,fixedCacheKey:g}={})=>(d,a)=>{let n=l({type:"mutation",endpointName:i,originalArgs:T,track:E,fixedCacheKey:g}),r=d(n);let{requestId:o,abort:m,unwrap:F}=r,C=ht(r.unwrap().then(O=>({data:O})),O=>({error:O})),N=()=>{d(D({requestId:o,fixedCacheKey:g}))},v=Object.assign(C,{arg:r.arg,requestId:o,abort:m,unwrap:F,reset:N}),I=M(d);return I.set(o,v),v.then(()=>{I.delete(o)}),g&&(I.set(g,v),v.then(()=>{I.get(g)===v&&I.delete(g)})),v}}}var At=require("@standard-schema/utils"),ce=class extends At.SchemaError{constructor(u,l,p,S){super(u);this.value=l;this.schemaName=p;this._bqMeta=S}},oe=(e,t)=>Array.isArray(e)?e.includes(t):!!e;async function se(e,t,u,l){let p=await e["~standard"].validate(t);if(p.issues)throw new ce(p.issues,t,u,l);return p.value}function St(e){return e}var Ie=(e={})=>({...e,[s.SHOULD_AUTOBATCH]:!0});function xt({reducerPath:e,baseQuery:t,context:{endpointDefinitions:u},serializeQueryArgs:l,api:p,assertTagType:S,selectors:Q,onSchemaFailure:k,catchSchemaFailure:M,skipSchemaValidation:x}){let D=(n,r,o,m)=>(F,C)=>{let N=u[n],v=l({queryArgs:r,endpointDefinition:N,endpointName:n});if(F(p.internalActions.queryResultPatched({queryCacheKey:v,patches:o})),!m)return;let I=p.endpoints[n].select(r)(C()),O=be(N.providesTags,I.data,void 0,r,{},S);F(p.internalActions.updateProvidedBy([{queryCacheKey:v,providedTags:O}]))};function h(n,r,o=0){let m=[r,...n];return o&&m.length>o?m.slice(0,-1):m}function R(n,r,o=0){let m=[...n,r];return o&&m.length>o?m.slice(1):m}let b=(n,r,o,m=!0)=>(F,C)=>{let v=p.endpoints[n].select(r)(C()),I={patches:[],inversePatches:[],undo:()=>F(p.util.patchQueryData(n,r,I.inversePatches,m))};if(v.status===W)return I;let O;if("data"in v)if((0,H.isDraftable)(v.data)){let[_,$,G]=(0,H.produceWithPatches)(v.data,o);I.patches.push(...$),I.inversePatches.push(...G),O=_}else O=o(v.data),I.patches.push({op:"replace",path:[],value:O}),I.inversePatches.push({op:"replace",path:[],value:v.data});return I.patches.length===0||F(p.util.patchQueryData(n,r,I.patches,m)),I},w=(n,r,o)=>m=>m(p.endpoints[n].initiate(r,{subscribe:!1,forceRefetch:!0,[Ae]:()=>({data:o})})),P=(n,r)=>n.query&&n[r]?n[r]:St,f=async(n,{signal:r,abort:o,rejectWithValue:m,fulfillWithValue:F,dispatch:C,getState:N,extra:v})=>{let I=u[n.endpointName],{metaSchema:O,skipSchemaValidation:_=x}=I,$=n.type===te;try{let G=St,V={signal:r,abort:o,dispatch:C,getState:N,extra:v,endpoint:n.endpointName,type:n.type,forced:$?A(n,N()):void 0,queryCacheKey:$?n.queryCacheKey:void 0},z=$?n[Ae]:void 0,j,q=async(L,U,ne,Y)=>{if(U==null&&L.pages.length)return Promise.resolve({data:L});let fe={queryArg:n.originalArgs,pageParam:U},ee=await K(fe),me=Y?h:R;return{data:{pages:me(L.pages,ee.data,ne),pageParams:me(L.pageParams,U,ne)},meta:ee.meta}};async function K(L){let U,{extraOptions:ne,argSchema:Y,rawResponseSchema:fe,responseSchema:ee}=I;if(Y&&!oe(_,"arg")&&(L=await se(Y,L,"argSchema",{})),z?U=z():I.query?(G=P(I,"transformResponse"),U=await t(I.query(L),V,ne)):U=await I.queryFn(L,V,ne,ue=>t(ue,V,ne)),typeof process<"u",U.error)throw new Z(U.error,U.meta);let{data:me}=U;fe&&!oe(_,"rawResponse")&&(me=await se(fe,U.data,"rawResponseSchema",U.meta));let re=await G(me,U.meta,L);return ee&&!oe(_,"response")&&(re=await se(ee,re,"responseSchema",U.meta)),{...U,data:re}}if($&&"infiniteQueryOptions"in I){let{infiniteQueryOptions:L}=I,{maxPages:U=1/0}=L,ne=n.refetchCachedPages??L.refetchCachedPages??!0,Y,fe={pages:[],pageParams:[]},ee=Q.selectQueryEntry(N(),n.queryCacheKey)?.data,re=A(n,N())&&!n.direction||!ee?fe:ee;if("direction"in n&&n.direction&&re.pages.length){let ue=n.direction==="backward",Ce=(ue?Ge:Ne)(L,re,n.originalArgs);Y=await q(re,Ce,U,ue)}else{let{initialPageParam:ue=L.initialPageParam}=n,we=ee?.pageParams??[],Ce=we[0]??ue,zt=we.length;if(Y=await q(re,Ce,U),z&&(Y={data:Y.data.pages[0]}),ne)for(let et=1;et<zt;et++){let Wt=Ne(L,Y.data,n.originalArgs);Y=await q(Y.data,Wt,U)}}j=Y}else j=await K(n.originalArgs);return O&&!oe(_,"meta")&&j.meta&&(j.meta=await se(O,j.meta,"metaSchema",j.meta)),F(j.data,Ie({fulfilledTimeStamp:Date.now(),baseQueryMeta:j.meta}))}catch(G){let V=G;if(V instanceof Z){let z=P(I,"transformErrorResponse"),{rawErrorResponseSchema:j,errorResponseSchema:q}=I,{value:K,meta:L}=V;try{j&&!oe(_,"rawErrorResponse")&&(K=await se(j,K,"rawErrorResponseSchema",L)),O&&!oe(_,"meta")&&(L=await se(O,L,"metaSchema",L));let U=await z(K,L,n.originalArgs);return q&&!oe(_,"errorResponse")&&(U=await se(q,U,"errorResponseSchema",L)),m(U,Ie({baseQueryMeta:L}))}catch(U){V=U}}try{if(V instanceof ce){let z={endpoint:n.endpointName,arg:n.originalArgs,type:n.type,queryCacheKey:$?n.queryCacheKey:void 0};I.onSchemaFailure?.(V,z),k?.(V,z);let{catchSchemaFailure:j=M}=I;if(j)return m(j(V,z),Ie({baseQueryMeta:V._bqMeta}))}}catch(z){V=z}throw typeof process<"u",console.error(V),V}};function A(n,r){let o=Q.selectQueryEntry(r,n.queryCacheKey),m=Q.selectConfig(r).refetchOnMountOrArgChange,F=o?.fulfilledTimeStamp,C=n.forceRefetch??(n.subscribe&&m);return C?C===!0||(Number(new Date)-Number(F))/1e3>=C:!1}let B=()=>(0,s.createAsyncThunk)(`${e}/executeQuery`,f,{getPendingMeta({arg:r}){let o=u[r.endpointName];return Ie({startedTimeStamp:Date.now(),...de(o)?{direction:r.direction}:{}})},condition(r,{getState:o}){let m=o(),F=Q.selectQueryEntry(m,r.queryCacheKey),C=F?.fulfilledTimeStamp,N=r.originalArgs,v=F?.originalArgs,I=u[r.endpointName],O=r.direction;return Pe(r)?!0:F?.status==="pending"?!1:A(r,m)||pe(I)&&I?.forceRefetch?.({currentArg:N,previousArg:v,endpointState:F,state:m})?!0:!(C&&!O)},dispatchConditionRejection:!0}),y=B(),c=B(),i=(0,s.createAsyncThunk)(`${e}/executeMutation`,f,{getPendingMeta(){return Ie({startedTimeStamp:Date.now()})}}),T=n=>"force"in n,E=n=>"ifOlderThan"in n,g=(n,r,o={})=>(m,F)=>{let C=T(o)&&o.force,N=E(o)&&o.ifOlderThan,v=(O=!0)=>{let _={forceRefetch:O,subscribe:!1};return p.endpoints[n].initiate(r,_)},I=p.endpoints[n].select(r)(F());if(C)m(v());else if(N){let O=I?.fulfilledTimeStamp;if(!O){m(v());return}(Number(new Date)-Number(new Date(O)))/1e3>=N&&m(v())}else m(v(!1))};function d(n){return r=>r?.meta?.arg?.endpointName===n}function a(n,r){return{matchPending:(0,s.isAllOf)((0,s.isPending)(n),d(r)),matchFulfilled:(0,s.isAllOf)((0,s.isFulfilled)(n),d(r)),matchRejected:(0,s.isAllOf)((0,s.isRejected)(n),d(r))}}return{queryThunk:y,mutationThunk:i,infiniteQueryThunk:c,prefetch:g,updateQueryData:b,upsertQueryData:w,patchQueryData:D,buildMatchThunkActions:a}}function Ne(e,{pages:t,pageParams:u},l){let p=t.length-1;return e.getNextPageParam(t[p],t,u[p],u,l)}function Ge(e,{pages:t,pageParams:u},l){return e.getPreviousPageParam?.(t[0],t,u[0],u,l)}function Ue(e,t,u,l){return be(u[e.meta.arg.endpointName][t],(0,s.isFulfilled)(e)?e.payload:void 0,(0,s.isRejectedWithValue)(e)?e.payload:void 0,e.meta.arg.originalArgs,"baseQueryMeta"in e.meta?e.meta.baseQueryMeta:void 0,l)}function Ze(e){return(0,H.isDraft)(e)?(0,H.current)(e):e}function qe(e,t,u){let l=e[t];l&&u(l)}function le(e){return("arg"in e?e.arg.fixedCacheKey:e.fixedCacheKey)??e.requestId}function Dt(e,t,u){let l=e[le(t)];l&&u(l)}var Ke={};function Et({reducerPath:e,queryThunk:t,mutationThunk:u,serializeQueryArgs:l,context:{endpointDefinitions:p,apiUid:S,extractRehydrationInfo:Q,hasRehydrationInfo:k},assertTagType:M,config:x}){let D=(0,s.createAction)(`${e}/resetApiState`);function h(d,a,n,r){d[a.queryCacheKey]??={status:W,endpointName:a.endpointName},qe(d,a.queryCacheKey,o=>{o.status=Fe,o.requestId=n&&o.requestId?o.requestId:r.requestId,a.originalArgs!==void 0&&(o.originalArgs=a.originalArgs),o.startedTimeStamp=r.startedTimeStamp;let m=p[r.arg.endpointName];de(m)&&"direction"in a&&(o.direction=a.direction)})}function R(d,a,n,r){qe(d,a.arg.queryCacheKey,o=>{if(o.requestId!==a.requestId&&!r)return;let{merge:m}=p[a.arg.endpointName];if(o.status=ge,m)if(o.data!==void 0){let{fulfilledTimeStamp:F,arg:C,baseQueryMeta:N,requestId:v}=a,I=(0,s.createNextState)(o.data,O=>m(O,n,{arg:C.originalArgs,baseQueryMeta:N,fulfilledTimeStamp:F,requestId:v}));o.data=I}else o.data=n;else o.data=p[a.arg.endpointName].structuralSharing??!0?Se((0,H.isDraft)(o.data)?(0,H.original)(o.data):o.data,n):n;delete o.error,o.fulfilledTimeStamp=a.fulfilledTimeStamp})}let b=(0,s.createSlice)({name:`${e}/queries`,initialState:Ke,reducers:{removeQueryResult:{reducer(d,{payload:{queryCacheKey:a}}){delete d[a]},prepare:(0,s.prepareAutoBatched)()},cacheEntriesUpserted:{reducer(d,a){for(let n of a.payload){let{queryDescription:r,value:o}=n;h(d,r,!0,{arg:r,requestId:a.meta.requestId,startedTimeStamp:a.meta.timestamp}),R(d,{arg:r,requestId:a.meta.requestId,fulfilledTimeStamp:a.meta.timestamp,baseQueryMeta:{}},o,!0)}},prepare:d=>({payload:d.map(r=>{let{endpointName:o,arg:m,value:F}=r,C=p[o];return{queryDescription:{type:te,endpointName:o,originalArgs:r.arg,queryCacheKey:l({queryArgs:m,endpointDefinition:C,endpointName:o})},value:F}}),meta:{[s.SHOULD_AUTOBATCH]:!0,requestId:(0,s.nanoid)(),timestamp:Date.now()}})},queryResultPatched:{reducer(d,{payload:{queryCacheKey:a,patches:n}}){qe(d,a,r=>{r.data=(0,H.applyPatches)(r.data,n.concat())})},prepare:(0,s.prepareAutoBatched)()}},extraReducers(d){d.addCase(t.pending,(a,{meta:n,meta:{arg:r}})=>{let o=Pe(r);h(a,r,o,n)}).addCase(t.fulfilled,(a,{meta:n,payload:r})=>{let o=Pe(n.arg);R(a,n,r,o)}).addCase(t.rejected,(a,{meta:{condition:n,arg:r,requestId:o},error:m,payload:F})=>{qe(a,r.queryCacheKey,C=>{if(!n){if(C.requestId!==o)return;C.status=Qe,C.error=F??m}})}).addMatcher(k,(a,n)=>{let{queries:r}=Q(n);for(let[o,m]of Object.entries(r))(m?.status===ge||m?.status===Qe)&&(a[o]=m)})}}),w=(0,s.createSlice)({name:`${e}/mutations`,initialState:Ke,reducers:{removeMutationResult:{reducer(d,{payload:a}){let n=le(a);n in d&&delete d[n]},prepare:(0,s.prepareAutoBatched)()}},extraReducers(d){d.addCase(u.pending,(a,{meta:n,meta:{requestId:r,arg:o,startedTimeStamp:m}})=>{o.track&&(a[le(n)]={requestId:r,status:Fe,endpointName:o.endpointName,startedTimeStamp:m})}).addCase(u.fulfilled,(a,{payload:n,meta:r})=>{r.arg.track&&Dt(a,r,o=>{o.requestId===r.requestId&&(o.status=ge,o.data=n,o.fulfilledTimeStamp=r.fulfilledTimeStamp)})}).addCase(u.rejected,(a,{payload:n,error:r,meta:o})=>{o.arg.track&&Dt(a,o,m=>{m.requestId===o.requestId&&(m.status=Qe,m.error=n??r)})}).addMatcher(k,(a,n)=>{let{mutations:r}=Q(n);for(let[o,m]of Object.entries(r))(m?.status===ge||m?.status===Qe)&&o!==m?.requestId&&(a[o]=m)})}}),P={tags:{},keys:{}},f=(0,s.createSlice)({name:`${e}/invalidation`,initialState:P,reducers:{updateProvidedBy:{reducer(d,a){for(let{queryCacheKey:n,providedTags:r}of a.payload){A(d,n);for(let{type:o,id:m}of r){let F=(d.tags[o]??={})[m||"__internal_without_id"]??=[];F.includes(n)||F.push(n)}d.keys[n]=r}},prepare:(0,s.prepareAutoBatched)()}},extraReducers(d){d.addCase(b.actions.removeQueryResult,(a,{payload:{queryCacheKey:n}})=>{A(a,n)}).addMatcher(k,(a,n)=>{let{provided:r}=Q(n);for(let[o,m]of Object.entries(r.tags??{}))for(let[F,C]of Object.entries(m)){let N=(a.tags[o]??={})[F||"__internal_without_id"]??=[];for(let v of C)N.includes(v)||N.push(v),a.keys[v]=r.keys[v]}}).addMatcher((0,s.isAnyOf)((0,s.isFulfilled)(t),(0,s.isRejectedWithValue)(t)),(a,n)=>{B(a,[n])}).addMatcher(b.actions.cacheEntriesUpserted.match,(a,n)=>{let r=n.payload.map(({queryDescription:o,value:m})=>({type:"UNKNOWN",payload:m,meta:{requestStatus:"fulfilled",requestId:"UNKNOWN",arg:o}}));B(a,r)})}});function A(d,a){let n=Ze(d.keys[a]??[]);for(let r of n){let o=r.type,m=r.id??"__internal_without_id",F=d.tags[o]?.[m];F&&(d.tags[o][m]=Ze(F).filter(C=>C!==a))}delete d.keys[a]}function B(d,a){let n=a.map(r=>{let o=Ue(r,"providesTags",p,M),{queryCacheKey:m}=r.meta.arg;return{queryCacheKey:m,providedTags:o}});f.caseReducers.updateProvidedBy(d,f.actions.updateProvidedBy(n))}let y=(0,s.createSlice)({name:`${e}/subscriptions`,initialState:Ke,reducers:{updateSubscriptionOptions(d,a){},unsubscribeQueryResult(d,a){},internal_getRTKQSubscriptions(){}}}),c=(0,s.createSlice)({name:`${e}/internalSubscriptions`,initialState:Ke,reducers:{subscriptionsUpdated:{reducer(d,a){return(0,H.applyPatches)(d,a.payload)},prepare:(0,s.prepareAutoBatched)()}}}),i=(0,s.createSlice)({name:`${e}/config`,initialState:{online:it(),focused:rt(),middlewareRegistered:!1,...x},reducers:{middlewareRegistered(d,{payload:a}){d.middlewareRegistered=d.middlewareRegistered==="conflict"||S!==a?"conflict":!0}},extraReducers:d=>{d.addCase(ae,a=>{a.online=!0}).addCase(he,a=>{a.online=!1}).addCase(ie,a=>{a.focused=!0}).addCase(Te,a=>{a.focused=!1}).addMatcher(k,a=>({...a}))}}),T=(0,s.combineReducers)({queries:b.reducer,mutations:w.reducer,provided:f.reducer,subscriptions:c.reducer,config:i.reducer}),E=(d,a)=>T(D.match(a)?void 0:d,a),g={...i.actions,...b.actions,...y.actions,...c.actions,...w.actions,...f.actions,resetApiState:D};return{reducer:E,actions:g}}var Be=Symbol.for("RTKQ/skipToken"),It={status:W},bt=(0,s.createNextState)(It,()=>{}),Pt=(0,s.createNextState)(It,()=>{});function Bt({serializeQueryArgs:e,reducerPath:t,createSelector:u}){let l=y=>bt,p=y=>Pt;return{buildQuerySelector:R,buildInfiniteQuerySelector:b,buildMutationSelector:w,selectInvalidatedBy:P,selectCachedArgsForQuery:f,selectApiState:Q,selectQueries:k,selectMutations:x,selectQueryEntry:M,selectConfig:D};function S(y){return{...y,...je(y.status)}}function Q(y){return y[t]}function k(y){return Q(y)?.queries}function M(y,c){return k(y)?.[c]}function x(y){return Q(y)?.mutations}function D(y){return Q(y)?.config}function h(y,c,i){return T=>{if(T===Be)return u(l,i);let E=e({queryArgs:T,endpointDefinition:c,endpointName:y});return u(d=>M(d,E)??bt,i)}}function R(y,c){return h(y,c,S)}function b(y,c){let{infiniteQueryOptions:i}=c;function T(E){let g={...E,...je(E.status)},{isLoading:d,isError:a,direction:n}=g,r=n==="forward",o=n==="backward";return{...g,hasNextPage:A(i,g.data,g.originalArgs),hasPreviousPage:B(i,g.data,g.originalArgs),isFetchingNextPage:d&&r,isFetchingPreviousPage:d&&o,isFetchNextPageError:a&&r,isFetchPreviousPageError:a&&o}}return h(y,c,T)}function w(){return y=>{let c;return typeof y=="object"?c=le(y)??Be:c=y,u(c===Be?p:E=>Q(E)?.mutations?.[c]??Pt,S)}}function P(y,c){let i=y[t],T=new Set,E=xe(c,De,Je);for(let g of E){let d=i.provided.tags[g.type];if(!d)continue;let a=(g.id!==void 0?d[g.id]:Object.values(d).flat())??[];for(let n of a)T.add(n)}return Array.from(T.values()).flatMap(g=>{let d=i.queries[g];return d?{queryCacheKey:g,endpointName:d.endpointName,originalArgs:d.originalArgs}:[]})}function f(y,c){return xe(Object.values(k(y)),i=>i?.endpointName===c&&i.status!==W,i=>i.originalArgs)}function A(y,c,i){return c?Ne(y,c,i)!=null:!1}function B(y,c,i){return!c||!y.getPreviousPageParam?!1:Ge(y,c,i)!=null}}var Mt=require("@reduxjs/toolkit");var kt=WeakMap?new WeakMap:void 0,ke=({endpointName:e,queryArgs:t})=>{let u="",l=kt?.get(t);if(typeof l=="string")u=l;else{let p=JSON.stringify(t,(S,Q)=>(Q=typeof Q=="bigint"?{$bigint:Q.toString()}:Q,Q=(0,s.isPlainObject)(Q)?Object.keys(Q).sort().reduce((k,M)=>(k[M]=Q[M],k),{}):Q,Q));(0,s.isPlainObject)(t)&&kt?.set(t,p),u=p}return`${e}(${u})`};var Xe=require("reselect");function Le(...e){return function(u){let l=(0,Xe.weakMapMemoize)(x=>u.extractRehydrationInfo?.(x,{reducerPath:u.reducerPath??"api"})),p={reducerPath:"api",keepUnusedDataFor:60,refetchOnMountOrArgChange:!1,refetchOnFocus:!1,refetchOnReconnect:!1,invalidationBehavior:"delayed",...u,extractRehydrationInfo:l,serializeQueryArgs(x){let D=ke;if("serializeQueryArgs"in x.endpointDefinition){let h=x.endpointDefinition.serializeQueryArgs;D=R=>{let b=h(R);return typeof b=="string"?b:ke({...R,queryArgs:b})}}else u.serializeQueryArgs&&(D=u.serializeQueryArgs);return D(x)},tagTypes:[...u.tagTypes||[]]},S={endpointDefinitions:{},batch(x){x()},apiUid:(0,s.nanoid)(),extractRehydrationInfo:l,hasRehydrationInfo:(0,Xe.weakMapMemoize)(x=>l(x)!=null)},Q={injectEndpoints:M,enhanceEndpoints({addTagTypes:x,endpoints:D}){if(x)for(let h of x)p.tagTypes.includes(h)||p.tagTypes.push(h);if(D)for(let[h,R]of Object.entries(D))typeof R=="function"?R(J(S,h)):Object.assign(J(S,h)||{},R);return Q}},k=e.map(x=>x.init(Q,p,S));function M(x){let D=x.endpoints({query:h=>({...h,type:te}),mutation:h=>({...h,type:$e}),infiniteQuery:h=>({...h,type:Ye})});for(let[h,R]of Object.entries(D)){if(x.overrideExisting!==!0&&h in S.endpointDefinitions){if(x.overrideExisting==="throw")throw new Error((0,Mt.formatProdErrorMessage)(39));typeof process<"u";continue}typeof process<"u",S.endpointDefinitions[h]=R;for(let b of k)b.injectEndpoint(h,R)}return Q}return Q.injectEndpoints({endpoints:u.endpoints})}}var wt=require("@reduxjs/toolkit"),Ct=Symbol();function Ft(){return function(){throw new Error((0,wt.formatProdErrorMessage)(33))}}function X(e,...t){return Object.assign(e,...t)}var vt=({api:e,queryThunk:t,internalState:u,mwApi:l})=>{let p=`${e.reducerPath}/subscriptions`,S=null,Q=null,{updateSubscriptionOptions:k,unsubscribeQueryResult:M}=e.internalActions,x=(P,f)=>{if(k.match(f)){let{queryCacheKey:B,requestId:y,options:c}=f.payload,i=P.get(B);return i?.has(y)&&i.set(y,c),!0}if(M.match(f)){let{queryCacheKey:B,requestId:y}=f.payload,c=P.get(B);return c&&c.delete(y),!0}if(e.internalActions.removeQueryResult.match(f))return P.delete(f.payload.queryCacheKey),!0;if(t.pending.match(f)){let{meta:{arg:B,requestId:y}}=f,c=ye(P,B.queryCacheKey,Ee);return B.subscribe&&c.set(y,B.subscriptionOptions??c.get(y)??{}),!0}let A=!1;if(t.rejected.match(f)){let{meta:{condition:B,arg:y,requestId:c}}=f;if(B&&y.subscribe){let i=ye(P,y.queryCacheKey,Ee);i.set(c,y.subscriptionOptions??i.get(c)??{}),A=!0}}return A},D=()=>u.currentSubscriptions,b={getSubscriptions:D,getSubscriptionCount:P=>D().get(P)?.size??0,isRequestSubscribed:(P,f)=>!!D()?.get(P)?.get(f)};function w(P){return JSON.parse(JSON.stringify(Object.fromEntries([...P].map(([f,A])=>[f,Object.fromEntries(A)]))))}return(P,f)=>{if(S||(S=w(u.currentSubscriptions)),e.util.resetApiState.match(P))return S={},u.currentSubscriptions.clear(),Q=null,[!0,!1];if(e.internalActions.internal_getRTKQSubscriptions.match(P))return[!1,b];let A=x(u.currentSubscriptions,P),B=!0;if(A){Q||(Q=setTimeout(()=>{let i=w(u.currentSubscriptions),[,T]=(0,H.produceWithPatches)(S,()=>i);f.next(e.internalActions.subscriptionsUpdated(T)),S=i,Q=null},500));let y=typeof P.type=="string"&&!!P.type.startsWith(p),c=t.rejected.match(P)&&P.meta.condition&&!!P.meta.arg.subscribe;B=!y&&!c}return[B,!1]}};var cn=2147483647/1e3-1,Ot=({reducerPath:e,api:t,queryThunk:u,context:l,internalState:p,selectors:{selectQueryEntry:S,selectConfig:Q},getRunningQueryThunk:k,mwApi:M})=>{let{removeQueryResult:x,unsubscribeQueryResult:D,cacheEntriesUpserted:h}=t.internalActions,R=(0,s.isAnyOf)(D.match,u.fulfilled,u.rejected,h.match);function b(y){let c=p.currentSubscriptions.get(y);return c?c.size>0:!1}let w={};function P(y){for(let c of y.values())c?.abort?.()}let f=(y,c)=>{let i=c.getState(),T=Q(i);if(R(y)){let E;if(h.match(y))E=y.payload.map(g=>g.queryDescription.queryCacheKey);else{let{queryCacheKey:g}=D.match(y)?y.payload:y.meta.arg;E=[g]}A(E,c,T)}if(t.util.resetApiState.match(y)){for(let[E,g]of Object.entries(w))g&&clearTimeout(g),delete w[E];P(p.runningQueries),P(p.runningMutations)}if(l.hasRehydrationInfo(y)){let{queries:E}=l.extractRehydrationInfo(y);A(Object.keys(E),c,T)}};function A(y,c,i){let T=c.getState();for(let E of y){let g=S(T,E);g?.endpointName&&B(E,g.endpointName,c,i)}}function B(y,c,i,T){let g=J(l,c)?.keepUnusedDataFor??T.keepUnusedDataFor;if(g===1/0)return;let d=Math.max(0,Math.min(g,cn));if(!b(y)){let a=w[y];a&&clearTimeout(a),w[y]=setTimeout(()=>{if(!b(y)){let n=S(i.getState(),y);n?.endpointName&&i.dispatch(k(n.endpointName,n.originalArgs))?.abort(),i.dispatch(x({queryCacheKey:y}))}delete w[y]},d*1e3)}}return f};var Nt=new Error("Promise never resolved before cacheEntryRemoved."),Ut=({api:e,reducerPath:t,context:u,queryThunk:l,mutationThunk:p,internalState:S,selectors:{selectQueryEntry:Q,selectApiState:k}})=>{let M=(0,s.isAsyncThunkAction)(l),x=(0,s.isAsyncThunkAction)(p),D=(0,s.isFulfilled)(l,p),h={},{removeQueryResult:R,removeMutationResult:b,cacheEntriesUpserted:w}=e.internalActions;function P(i,T,E){let g=h[i];g?.valueResolved&&(g.valueResolved({data:T,meta:E}),delete g.valueResolved)}function f(i){let T=h[i];T&&(delete h[i],T.cacheEntryRemoved())}function A(i){let{arg:T,requestId:E}=i.meta,{endpointName:g,originalArgs:d}=T;return[g,d,E]}let B=(i,T,E)=>{let g=y(i);function d(a,n,r,o){let m=Q(E,n),F=Q(T.getState(),n);!m&&F&&c(a,o,n,T,r)}if(l.pending.match(i)){let[a,n,r]=A(i);d(a,g,r,n)}else if(w.match(i))for(let{queryDescription:a,value:n}of i.payload){let{endpointName:r,originalArgs:o,queryCacheKey:m}=a;d(r,m,i.meta.requestId,o),P(m,n,{})}else if(p.pending.match(i)){if(T.getState()[t].mutations[g]){let[n,r,o]=A(i);c(n,r,g,T,o)}}else if(D(i))P(g,i.payload,i.meta.baseQueryMeta);else if(R.match(i)||b.match(i))f(g);else if(e.util.resetApiState.match(i))for(let a of Object.keys(h))f(a)};function y(i){return M(i)?i.meta.arg.queryCacheKey:x(i)?i.meta.arg.fixedCacheKey??i.meta.requestId:R.match(i)?i.payload.queryCacheKey:b.match(i)?le(i.payload):""}function c(i,T,E,g,d){let a=J(u,i),n=a?.onCacheEntryAdded;if(!n)return;let r={},o=new Promise(I=>{r.cacheEntryRemoved=I}),m=Promise.race([new Promise(I=>{r.valueResolved=I}),o.then(()=>{throw Nt})]);m.catch(()=>{}),h[E]=r;let F=e.endpoints[i].select(Re(a)?T:E),C=g.dispatch((I,O,_)=>_),N={...g,getCacheEntry:()=>F(g.getState()),requestId:d,extra:C,updateCachedData:Re(a)?I=>g.dispatch(e.util.updateQueryData(i,T,I)):void 0,cacheDataLoaded:m,cacheEntryRemoved:o},v=n(T,N);Promise.resolve(v).catch(I=>{if(I!==Nt)throw I})}return B};var qt=({api:e,context:{apiUid:t},reducerPath:u})=>(l,p)=>{e.util.resetApiState.match(l)&&p.dispatch(e.internalActions.middlewareRegistered(t)),typeof process<"u"};var Kt=({reducerPath:e,context:t,context:{endpointDefinitions:u},mutationThunk:l,queryThunk:p,api:S,assertTagType:Q,refetchQuery:k,internalState:M})=>{let{removeQueryResult:x}=S.internalActions,D=(0,s.isAnyOf)((0,s.isFulfilled)(l),(0,s.isRejectedWithValue)(l)),h=(0,s.isAnyOf)((0,s.isFulfilled)(p,l),(0,s.isRejected)(p,l)),R=[],b=0,w=(A,B)=>{(p.pending.match(A)||l.pending.match(A))&&b++,h(A)&&(b=Math.max(0,b-1)),D(A)?f(Ue(A,"invalidatesTags",u,Q),B):h(A)?f([],B):S.util.invalidateTags.match(A)&&f(be(A.payload,void 0,void 0,void 0,void 0,Q),B)};function P(){return b>0}function f(A,B){let y=B.getState(),c=y[e];if(R.push(...A),c.config.invalidationBehavior==="delayed"&&P())return;let i=R;if(R=[],i.length===0)return;let T=S.util.selectInvalidatedBy(y,i);t.batch(()=>{let E=Array.from(T.values());for(let{queryCacheKey:g}of E){let d=c.queries[g],a=ye(M.currentSubscriptions,g,Ee);d&&(a.size===0?B.dispatch(x({queryCacheKey:g})):d.status!==W&&B.dispatch(k(d)))}})}return w};var Lt=({reducerPath:e,queryThunk:t,api:u,refetchQuery:l,internalState:p})=>{let{currentPolls:S,currentSubscriptions:Q}=p,k=new Set,M=null,x=(f,A)=>{(u.internalActions.updateSubscriptionOptions.match(f)||u.internalActions.unsubscribeQueryResult.match(f))&&D(f.payload.queryCacheKey,A),(t.pending.match(f)||t.rejected.match(f)&&f.meta.condition)&&D(f.meta.arg.queryCacheKey,A),(t.fulfilled.match(f)||t.rejected.match(f)&&!f.meta.condition)&&h(f.meta.arg,A),u.util.resetApiState.match(f)&&(w(),M&&(clearTimeout(M),M=null),k.clear())};function D(f,A){k.add(f),M||(M=setTimeout(()=>{for(let B of k)R({queryCacheKey:B},A);k.clear(),M=null},0))}function h({queryCacheKey:f},A){let B=A.getState()[e],y=B.queries[f],c=Q.get(f);if(!y||y.status===W)return;let{lowestPollingInterval:i,skipPollingIfUnfocused:T}=P(c);if(!Number.isFinite(i))return;let E=S.get(f);E?.timeout&&(clearTimeout(E.timeout),E.timeout=void 0);let g=Date.now()+i;S.set(f,{nextPollTimestamp:g,pollingInterval:i,timeout:setTimeout(()=>{(B.config.focused||!T)&&A.dispatch(l(y)),h({queryCacheKey:f},A)},i)})}function R({queryCacheKey:f},A){let y=A.getState()[e].queries[f],c=Q.get(f);if(!y||y.status===W)return;let{lowestPollingInterval:i}=P(c);if(!Number.isFinite(i)){b(f);return}let T=S.get(f),E=Date.now()+i;(!T||E<T.nextPollTimestamp)&&h({queryCacheKey:f},A)}function b(f){let A=S.get(f);A?.timeout&&clearTimeout(A.timeout),S.delete(f)}function w(){for(let f of S.keys())b(f)}function P(f=new Map){let A=!1,B=Number.POSITIVE_INFINITY;for(let y of f.values())y.pollingInterval&&(B=Math.min(y.pollingInterval,B),A=y.skipPollingIfUnfocused||A);return{lowestPollingInterval:B,skipPollingIfUnfocused:A}}return x};var _t=({api:e,context:t,queryThunk:u,mutationThunk:l})=>{let p=(0,s.isPending)(u,l),S=(0,s.isRejected)(u,l),Q=(0,s.isFulfilled)(u,l),k={};return(x,D)=>{if(p(x)){let{requestId:h,arg:{endpointName:R,originalArgs:b}}=x.meta,w=J(t,R),P=w?.onQueryStarted;if(P){let f={},A=new Promise((i,T)=>{f.resolve=i,f.reject=T});A.catch(()=>{}),k[h]=f;let B=e.endpoints[R].select(Re(w)?b:h),y=D.dispatch((i,T,E)=>E),c={...D,getCacheEntry:()=>B(D.getState()),requestId:h,extra:y,updateCachedData:Re(w)?i=>D.dispatch(e.util.updateQueryData(R,b,i)):void 0,queryFulfilled:A};P(b,c)}}else if(Q(x)){let{requestId:h,baseQueryMeta:R}=x.meta;k[h]?.resolve({data:x.payload,meta:R}),delete k[h]}else if(S(x)){let{requestId:h,rejectedWithValue:R,baseQueryMeta:b}=x.meta;k[h]?.reject({error:x.payload??x.error,isUnhandledError:!R,meta:b}),delete k[h]}}};var Ht=({reducerPath:e,context:t,api:u,refetchQuery:l,internalState:p})=>{let{removeQueryResult:S}=u.internalActions,Q=(M,x)=>{ie.match(M)&&k(x,"refetchOnFocus"),ae.match(M)&&k(x,"refetchOnReconnect")};function k(M,x){let D=M.getState()[e],h=D.queries,R=p.currentSubscriptions;t.batch(()=>{for(let b of R.keys()){let w=h[b],P=R.get(b);if(!P||!w)continue;let f=[...P.values()];(f.some(B=>B[x]===!0)||f.every(B=>B[x]===void 0)&&D.config[x])&&(P.size===0?M.dispatch(S({queryCacheKey:b})):w.status!==W&&M.dispatch(l(w)))}})}return Q};function Vt(e){let{reducerPath:t,queryThunk:u,api:l,context:p,getInternalState:S}=e,{apiUid:Q}=p,k={invalidateTags:(0,s.createAction)(`${t}/invalidateTags`)},M=R=>R.type.startsWith(`${t}/`),x=[qt,Ot,Kt,Lt,Ut,_t];return{middleware:R=>{let b=!1,w=S(R.dispatch),P={...e,internalState:w,refetchQuery:h,isThisApiSliceAction:M,mwApi:R},f=x.map(y=>y(P)),A=vt(P),B=Ht(P);return y=>c=>{if(!(0,s.isAction)(c))return y(c);b||(b=!0,R.dispatch(l.internalActions.middlewareRegistered(Q)));let i={...R,next:y},T=R.getState(),[E,g]=A(c,i,T),d;if(E?d=y(c):d=g,R.getState()[t]&&(B(c,i,T),M(c)||p.hasRehydrationInfo(c)))for(let a of f)a(c,i,T);return d}},actions:k};function h(R){return e.api.endpoints[R.endpointName].initiate(R.originalArgs,{subscribe:!1,forceRefetch:!0})}}var Me=Symbol(),_e=({createSelector:e=s.createSelector}={})=>({name:Me,init(t,{baseQuery:u,tagTypes:l,reducerPath:p,serializeQueryArgs:S,keepUnusedDataFor:Q,refetchOnMountOrArgChange:k,refetchOnFocus:M,refetchOnReconnect:x,invalidationBehavior:D,onSchemaFailure:h,catchSchemaFailure:R,skipSchemaValidation:b},w){(0,H.enablePatches)();let P=q=>(typeof process<"u",q);Object.assign(t,{reducerPath:p,endpoints:{},internalActions:{onOnline:ae,onOffline:he,onFocus:ie,onFocusLost:Te},util:{}});let f=Bt({serializeQueryArgs:S,reducerPath:p,createSelector:e}),{selectInvalidatedBy:A,selectCachedArgsForQuery:B,buildQuerySelector:y,buildInfiniteQuerySelector:c,buildMutationSelector:i}=f;X(t.util,{selectInvalidatedBy:A,selectCachedArgsForQuery:B});let{queryThunk:T,infiniteQueryThunk:E,mutationThunk:g,patchQueryData:d,updateQueryData:a,upsertQueryData:n,prefetch:r,buildMatchThunkActions:o}=xt({baseQuery:u,reducerPath:p,context:w,api:t,serializeQueryArgs:S,assertTagType:P,selectors:f,onSchemaFailure:h,catchSchemaFailure:R,skipSchemaValidation:b}),{reducer:m,actions:F}=Et({context:w,queryThunk:T,infiniteQueryThunk:E,mutationThunk:g,serializeQueryArgs:S,reducerPath:p,assertTagType:P,config:{refetchOnFocus:M,refetchOnReconnect:x,refetchOnMountOrArgChange:k,keepUnusedDataFor:Q,reducerPath:p,invalidationBehavior:D}});X(t.util,{patchQueryData:d,updateQueryData:a,upsertQueryData:n,prefetch:r,resetApiState:F.resetApiState,upsertQueryEntries:F.cacheEntriesUpserted}),X(t.internalActions,F);let C=new WeakMap,N=q=>ye(C,q,()=>({currentSubscriptions:new Map,currentPolls:new Map,runningQueries:new Map,runningMutations:new Map})),{buildInitiateQuery:v,buildInitiateInfiniteQuery:I,buildInitiateMutation:O,getRunningMutationThunk:_,getRunningMutationsThunk:$,getRunningQueriesThunk:G,getRunningQueryThunk:V}=Rt({queryThunk:T,mutationThunk:g,infiniteQueryThunk:E,api:t,serializeQueryArgs:S,context:w,getInternalState:N});X(t.util,{getRunningMutationThunk:_,getRunningMutationsThunk:$,getRunningQueryThunk:V,getRunningQueriesThunk:G});let{middleware:z,actions:j}=Vt({reducerPath:p,context:w,queryThunk:T,mutationThunk:g,infiniteQueryThunk:E,api:t,assertTagType:P,selectors:f,getRunningQueryThunk:V,getInternalState:N});return X(t.util,j),X(t,{reducer:m,middleware:z}),{name:Me,injectEndpoint(q,K){let L=t,U=L.endpoints[q]??={};pe(K)&&X(U,{name:q,select:y(q,K),initiate:v(q,K)},o(T,q)),Tt(K)&&X(U,{name:q,select:i(),initiate:O(q)},o(g,q)),de(K)&&X(U,{name:q,select:c(q,K),initiate:I(q,K)},o(T,q))}}}});var jt=Le(_e());0&&(module.exports={NamedSchemaError,QueryStatus,_NEVER,buildCreateApi,copyWithStructuralSharing,coreModule,coreModuleName,createApi,defaultSerializeQueryArgs,fakeBaseQuery,fetchBaseQuery,retry,setupListeners,skipToken});
//# sourceMappingURL=rtk-query.production.min.cjs.map